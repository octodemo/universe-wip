{
  "$schema" : "https://json.schemastore.org/sarif-2.1.0.json",
  "version" : "2.1.0",
  "runs" : [ {
    "tool" : {
      "driver" : {
        "name" : "CodeQL",
        "organization" : "GitHub",
        "semanticVersion" : "2.15.1",
        "notifications" : [ {
          "id" : "cli/expected-extracted-files/java",
          "name" : "cli/expected-extracted-files/java",
          "shortDescription" : {
            "text" : "Expected extracted files"
          },
          "fullDescription" : {
            "text" : "Files appearing in the source archive that are expected to be extracted."
          },
          "defaultConfiguration" : {
            "enabled" : true
          },
          "properties" : {
            "tags" : [ "expected-extracted-files", "telemetry" ],
            "languageDisplayName" : "Java"
          }
        }, {
          "id" : "cli/expected-extracted-files/go",
          "name" : "cli/expected-extracted-files/go",
          "shortDescription" : {
            "text" : "Expected extracted files"
          },
          "fullDescription" : {
            "text" : "Files appearing in the source archive that are expected to be extracted."
          },
          "defaultConfiguration" : {
            "enabled" : true
          },
          "properties" : {
            "tags" : [ "expected-extracted-files", "telemetry" ],
            "languageDisplayName" : "Go"
          }
        }, {
          "id" : "cli/expected-extracted-files/javascript",
          "name" : "cli/expected-extracted-files/javascript",
          "shortDescription" : {
            "text" : "Expected extracted files"
          },
          "fullDescription" : {
            "text" : "Files appearing in the source archive that are expected to be extracted."
          },
          "defaultConfiguration" : {
            "enabled" : true
          },
          "properties" : {
            "tags" : [ "expected-extracted-files", "telemetry" ],
            "languageDisplayName" : "JavaScript"
          }
        }, {
          "id" : "cli/expected-extracted-files/python",
          "name" : "cli/expected-extracted-files/python",
          "shortDescription" : {
            "text" : "Expected extracted files"
          },
          "fullDescription" : {
            "text" : "Files appearing in the source archive that are expected to be extracted."
          },
          "defaultConfiguration" : {
            "enabled" : true
          },
          "properties" : {
            "tags" : [ "expected-extracted-files", "telemetry" ],
            "languageDisplayName" : "Python"
          }
        }, {
          "id" : "go/autobuilder/multiple-go-mod-found-not-nested",
          "name" : "go/autobuilder/multiple-go-mod-found-not-nested",
          "shortDescription" : {
            "text" : "Multiple `go.mod` files found, not all nested under one root `go.mod` file"
          },
          "fullDescription" : {
            "text" : "Multiple `go.mod` files found, not all nested under one root `go.mod` file"
          },
          "defaultConfiguration" : {
            "enabled" : true
          }
        }, {
          "id" : "go/autobuilder/package-not-found",
          "name" : "go/autobuilder/package-not-found",
          "shortDescription" : {
            "text" : "Some packages could not be found"
          },
          "fullDescription" : {
            "text" : "Some packages could not be found"
          },
          "defaultConfiguration" : {
            "enabled" : true
          }
        } ],
        "rules" : [ ]
      },
      "extensions" : [ {
        "name" : "codeql/go-queries",
        "semanticVersion" : "0.7.1+8e890571ed7b21bc10698c5dbd032b9ed551d8f1",
        "notifications" : [ {
          "id" : "go/diagnostics/successfully-extracted-files",
          "name" : "go/diagnostics/successfully-extracted-files",
          "shortDescription" : {
            "text" : "Successfully analyzed files"
          },
          "fullDescription" : {
            "text" : "List all files that were successfully extracted."
          },
          "defaultConfiguration" : {
            "enabled" : true
          },
          "properties" : {
            "tags" : [ "successfully-extracted-files" ],
            "description" : "List all files that were successfully extracted.",
            "id" : "go/diagnostics/successfully-extracted-files",
            "kind" : "diagnostic",
            "name" : "Successfully analyzed files"
          }
        }, {
          "id" : "go/diagnostics/extraction-errors",
          "name" : "go/diagnostics/extraction-errors",
          "shortDescription" : {
            "text" : "Extraction errors"
          },
          "fullDescription" : {
            "text" : "List all extraction errors for files in the source code directory."
          },
          "defaultConfiguration" : {
            "enabled" : true
          },
          "properties" : {
            "description" : "List all extraction errors for files in the source code directory.",
            "id" : "go/diagnostics/extraction-errors",
            "kind" : "diagnostic",
            "name" : "Extraction errors"
          }
        } ],
        "rules" : [ {
          "id" : "go/incorrect-integer-conversion",
          "name" : "go/incorrect-integer-conversion",
          "shortDescription" : {
            "text" : "Incorrect conversion between integer types"
          },
          "fullDescription" : {
            "text" : "Converting the result of `strconv.Atoi`, `strconv.ParseInt`, and `strconv.ParseUint` to integer types of smaller bit size can produce unexpected values."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "warning"
          },
          "help" : {
            "text" : "# Incorrect conversion between integer types\nIf a string is parsed into an int using `strconv.Atoi`, and subsequently that int is converted into another integer type of a smaller size, the result can produce unexpected values.\n\nThis also applies to the results of `strconv.ParseInt` and `strconv.ParseUint` when the specified size is larger than the size of the type that number is converted to.\n\n\n## Recommendation\nIf you need to parse integer values with specific bit sizes, avoid `strconv.Atoi`, and instead use `strconv.ParseInt` or `strconv.ParseUint`, which also allow specifying the bit size.\n\nWhen using those functions, be careful to not convert the result to another type with a smaller bit size than the bit size you specified when parsing the number.\n\nIf this is not possible, then add upper (and lower) bound checks specific to each type and bit size (you can find the minimum and maximum value for each type in the `math` package).\n\n\n## Example\nIn the first example, assume that an input string is passed to `parseAllocateBad1` function, parsed by `strconv.Atoi`, and then converted into an `int32` type:\n\n\n```go\npackage main\n\nimport (\n\t\"strconv\"\n)\n\nfunc parseAllocateBad1(wanted string) int32 {\n\tparsed, err := strconv.Atoi(wanted)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateBad2(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\n\n```\nThe bounds are not checked, so this means that if the provided number is greater than the maximum value of type `int32`, the resulting value from the conversion will be different from the actual provided value.\n\nTo avoid unexpected values, you should either use the other functions provided by the `strconv` package to parse the specific types and bit sizes as shown in the `parseAllocateGood2` function; or check bounds as in the `parseAllocateGood1` function.\n\n\n```go\npackage main\n\nimport (\n\t\"math\"\n\t\"strconv\"\n)\n\nfunc main() {\n\n}\n\nconst DefaultAllocate int32 = 256\n\nfunc parseAllocateGood1(desired string) int32 {\n\tparsed, err := strconv.Atoi(desired)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\t// GOOD: check for lower and upper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\nfunc parseAllocateGood2(desired string) int32 {\n\t// GOOD: parse specifying the bit size\n\tparsed, err := strconv.ParseInt(desired, 10, 32)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\treturn int32(parsed)\n}\n\nfunc parseAllocateGood3(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 32)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateGood4(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// GOOD: check for lower and uppper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\n\n```\n\n## Example\nIn the second example, assume that an input string is passed to `parseAllocateBad2` function, parsed by `strconv.ParseInt` with a bit size set to 64, and then converted into an `int32` type:\n\n\n```go\npackage main\n\nimport (\n\t\"strconv\"\n)\n\nfunc parseAllocateBad1(wanted string) int32 {\n\tparsed, err := strconv.Atoi(wanted)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateBad2(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\n\n```\nIf the provided number is greater than the maximum value of type `int32`, the resulting value from the conversion will be different from the actual provided value.\n\nTo avoid unexpected values, you should specify the correct bit size as in `parseAllocateGood3`; or check bounds before making the conversion as in `parseAllocateGood4`.\n\n\n```go\npackage main\n\nimport (\n\t\"math\"\n\t\"strconv\"\n)\n\nfunc main() {\n\n}\n\nconst DefaultAllocate int32 = 256\n\nfunc parseAllocateGood1(desired string) int32 {\n\tparsed, err := strconv.Atoi(desired)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\t// GOOD: check for lower and upper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\nfunc parseAllocateGood2(desired string) int32 {\n\t// GOOD: parse specifying the bit size\n\tparsed, err := strconv.ParseInt(desired, 10, 32)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\treturn int32(parsed)\n}\n\nfunc parseAllocateGood3(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 32)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateGood4(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// GOOD: check for lower and uppper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\n\n```\n\n## References\n* Wikipedia [Integer overflow](https://en.wikipedia.org/wiki/Integer_overflow).\n* Go language specification [Integer overflow](https://golang.org/ref/spec#Integer_overflow).\n* Documentation for [strconv.Atoi](https://golang.org/pkg/strconv/#Atoi).\n* Documentation for [strconv.ParseInt](https://golang.org/pkg/strconv/#ParseInt).\n* Documentation for [strconv.ParseUint](https://golang.org/pkg/strconv/#ParseUint).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n",
            "markdown" : "# Incorrect conversion between integer types\nIf a string is parsed into an int using `strconv.Atoi`, and subsequently that int is converted into another integer type of a smaller size, the result can produce unexpected values.\n\nThis also applies to the results of `strconv.ParseInt` and `strconv.ParseUint` when the specified size is larger than the size of the type that number is converted to.\n\n\n## Recommendation\nIf you need to parse integer values with specific bit sizes, avoid `strconv.Atoi`, and instead use `strconv.ParseInt` or `strconv.ParseUint`, which also allow specifying the bit size.\n\nWhen using those functions, be careful to not convert the result to another type with a smaller bit size than the bit size you specified when parsing the number.\n\nIf this is not possible, then add upper (and lower) bound checks specific to each type and bit size (you can find the minimum and maximum value for each type in the `math` package).\n\n\n## Example\nIn the first example, assume that an input string is passed to `parseAllocateBad1` function, parsed by `strconv.Atoi`, and then converted into an `int32` type:\n\n\n```go\npackage main\n\nimport (\n\t\"strconv\"\n)\n\nfunc parseAllocateBad1(wanted string) int32 {\n\tparsed, err := strconv.Atoi(wanted)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateBad2(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\n\n```\nThe bounds are not checked, so this means that if the provided number is greater than the maximum value of type `int32`, the resulting value from the conversion will be different from the actual provided value.\n\nTo avoid unexpected values, you should either use the other functions provided by the `strconv` package to parse the specific types and bit sizes as shown in the `parseAllocateGood2` function; or check bounds as in the `parseAllocateGood1` function.\n\n\n```go\npackage main\n\nimport (\n\t\"math\"\n\t\"strconv\"\n)\n\nfunc main() {\n\n}\n\nconst DefaultAllocate int32 = 256\n\nfunc parseAllocateGood1(desired string) int32 {\n\tparsed, err := strconv.Atoi(desired)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\t// GOOD: check for lower and upper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\nfunc parseAllocateGood2(desired string) int32 {\n\t// GOOD: parse specifying the bit size\n\tparsed, err := strconv.ParseInt(desired, 10, 32)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\treturn int32(parsed)\n}\n\nfunc parseAllocateGood3(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 32)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateGood4(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// GOOD: check for lower and uppper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\n\n```\n\n## Example\nIn the second example, assume that an input string is passed to `parseAllocateBad2` function, parsed by `strconv.ParseInt` with a bit size set to 64, and then converted into an `int32` type:\n\n\n```go\npackage main\n\nimport (\n\t\"strconv\"\n)\n\nfunc parseAllocateBad1(wanted string) int32 {\n\tparsed, err := strconv.Atoi(wanted)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateBad2(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\n\n```\nIf the provided number is greater than the maximum value of type `int32`, the resulting value from the conversion will be different from the actual provided value.\n\nTo avoid unexpected values, you should specify the correct bit size as in `parseAllocateGood3`; or check bounds before making the conversion as in `parseAllocateGood4`.\n\n\n```go\npackage main\n\nimport (\n\t\"math\"\n\t\"strconv\"\n)\n\nfunc main() {\n\n}\n\nconst DefaultAllocate int32 = 256\n\nfunc parseAllocateGood1(desired string) int32 {\n\tparsed, err := strconv.Atoi(desired)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\t// GOOD: check for lower and upper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\nfunc parseAllocateGood2(desired string) int32 {\n\t// GOOD: parse specifying the bit size\n\tparsed, err := strconv.ParseInt(desired, 10, 32)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\treturn int32(parsed)\n}\n\nfunc parseAllocateGood3(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 32)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateGood4(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// GOOD: check for lower and uppper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\n\n```\n\n## References\n* Wikipedia [Integer overflow](https://en.wikipedia.org/wiki/Integer_overflow).\n* Go language specification [Integer overflow](https://golang.org/ref/spec#Integer_overflow).\n* Documentation for [strconv.Atoi](https://golang.org/pkg/strconv/#Atoi).\n* Documentation for [strconv.ParseInt](https://golang.org/pkg/strconv/#ParseInt).\n* Documentation for [strconv.ParseUint](https://golang.org/pkg/strconv/#ParseUint).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-190", "external/cwe/cwe-681" ],
            "description" : "Converting the result of `strconv.Atoi`, `strconv.ParseInt`,\n              and `strconv.ParseUint` to integer types of smaller bit size\n              can produce unexpected values.",
            "id" : "go/incorrect-integer-conversion",
            "kind" : "path-problem",
            "name" : "Incorrect conversion between integer types",
            "precision" : "very-high",
            "problem.severity" : "warning",
            "security-severity" : "8.1"
          }
        }, {
          "id" : "go/constant-oauth2-state",
          "name" : "go/constant-oauth2-state",
          "shortDescription" : {
            "text" : "Use of constant `state` value in OAuth 2.0 URL"
          },
          "fullDescription" : {
            "text" : "Using a constant value for the `state` in the OAuth 2.0 URL makes the application susceptible to CSRF attacks."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# Use of constant `state` value in OAuth 2.0 URL\nOAuth 2.0 clients must implement CSRF protection for the redirection URI, which is typically accomplished by including a \"state\" value that binds the request to the user's authenticated state. The Go OAuth 2.0 library allows you to specify a \"state\" value which is then included in the auth code URL. That state is then provided back by the remote authentication server in the redirect callback, from where it must be validated. Failure to do so makes the client susceptible to an CSRF attack.\n\n\n## Recommendation\nAlways include a unique, non-guessable `state` value (provided to the call to `AuthCodeURL` function) that is also bound to the user's authenticated state with each authentication request, and then validated in the redirect callback.\n\n\n## Example\nThe first example shows you the use of a constant state (bad).\n\n\n```go\npackage main\n\nimport (\n\t\"golang.org/x/oauth2\"\n)\n\nfunc main() {}\n\nvar stateStringVar = \"state\"\n\nfunc badWithStringLiteralState() {\n\tconf := &oauth2.Config{\n\t\tClientID:     \"YOUR_CLIENT_ID\",\n\t\tClientSecret: \"YOUR_CLIENT_SECRET\",\n\t\tScopes:       []string{\"SCOPE1\", \"SCOPE2\"},\n\t\tEndpoint: oauth2.Endpoint{\n\t\t\tAuthURL:  \"https://provider.com/o/oauth2/auth\",\n\t\t\tTokenURL: \"https://provider.com/o/oauth2/token\",\n\t\t},\n\t}\n\n\turl := conf.AuthCodeURL(stateStringVar)\n\t// ...\n}\n\n```\nThe second example shows a better implementation idea.\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"net/http\"\n\n\t\"golang.org/x/oauth2\"\n)\n\nfunc betterWithVariableStateReturned(w http.ResponseWriter) {\n\tconf := &oauth2.Config{\n\t\tClientID:     \"YOUR_CLIENT_ID\",\n\t\tClientSecret: \"YOUR_CLIENT_SECRET\",\n\t\tScopes:       []string{\"SCOPE1\", \"SCOPE2\"},\n\t\tEndpoint: oauth2.Endpoint{\n\t\t\tAuthURL:  \"https://provider.com/o/oauth2/auth\",\n\t\t\tTokenURL: \"https://provider.com/o/oauth2/token\",\n\t\t},\n\t}\n\n\tstate := generateStateOauthCookie(w)\n\turl := conf.AuthCodeURL(state)\n\t_ = url\n\t// ...\n}\nfunc generateStateOauthCookie(w http.ResponseWriter) string {\n\tb := make([]byte, 128)\n\trand.Read(b)\n\t// TODO: save the state string to cookies or HTML storage,\n\t// and bind it to the authenticated status of the user.\n\tstate := base64.URLEncoding.EncodeToString(b)\n\n\treturn state\n}\n\n```\n\n## References\n* IETF: [The OAuth 2.0 Authorization Framework](https://tools.ietf.org/html/rfc6749#section-10.12)\n* IETF: [OAuth 2.0 Security Best Current Practice](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-15#section-2.1)\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n",
            "markdown" : "# Use of constant `state` value in OAuth 2.0 URL\nOAuth 2.0 clients must implement CSRF protection for the redirection URI, which is typically accomplished by including a \"state\" value that binds the request to the user's authenticated state. The Go OAuth 2.0 library allows you to specify a \"state\" value which is then included in the auth code URL. That state is then provided back by the remote authentication server in the redirect callback, from where it must be validated. Failure to do so makes the client susceptible to an CSRF attack.\n\n\n## Recommendation\nAlways include a unique, non-guessable `state` value (provided to the call to `AuthCodeURL` function) that is also bound to the user's authenticated state with each authentication request, and then validated in the redirect callback.\n\n\n## Example\nThe first example shows you the use of a constant state (bad).\n\n\n```go\npackage main\n\nimport (\n\t\"golang.org/x/oauth2\"\n)\n\nfunc main() {}\n\nvar stateStringVar = \"state\"\n\nfunc badWithStringLiteralState() {\n\tconf := &oauth2.Config{\n\t\tClientID:     \"YOUR_CLIENT_ID\",\n\t\tClientSecret: \"YOUR_CLIENT_SECRET\",\n\t\tScopes:       []string{\"SCOPE1\", \"SCOPE2\"},\n\t\tEndpoint: oauth2.Endpoint{\n\t\t\tAuthURL:  \"https://provider.com/o/oauth2/auth\",\n\t\t\tTokenURL: \"https://provider.com/o/oauth2/token\",\n\t\t},\n\t}\n\n\turl := conf.AuthCodeURL(stateStringVar)\n\t// ...\n}\n\n```\nThe second example shows a better implementation idea.\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"net/http\"\n\n\t\"golang.org/x/oauth2\"\n)\n\nfunc betterWithVariableStateReturned(w http.ResponseWriter) {\n\tconf := &oauth2.Config{\n\t\tClientID:     \"YOUR_CLIENT_ID\",\n\t\tClientSecret: \"YOUR_CLIENT_SECRET\",\n\t\tScopes:       []string{\"SCOPE1\", \"SCOPE2\"},\n\t\tEndpoint: oauth2.Endpoint{\n\t\t\tAuthURL:  \"https://provider.com/o/oauth2/auth\",\n\t\t\tTokenURL: \"https://provider.com/o/oauth2/token\",\n\t\t},\n\t}\n\n\tstate := generateStateOauthCookie(w)\n\turl := conf.AuthCodeURL(state)\n\t_ = url\n\t// ...\n}\nfunc generateStateOauthCookie(w http.ResponseWriter) string {\n\tb := make([]byte, 128)\n\trand.Read(b)\n\t// TODO: save the state string to cookies or HTML storage,\n\t// and bind it to the authenticated status of the user.\n\tstate := base64.URLEncoding.EncodeToString(b)\n\n\treturn state\n}\n\n```\n\n## References\n* IETF: [The OAuth 2.0 Authorization Framework](https://tools.ietf.org/html/rfc6749#section-10.12)\n* IETF: [OAuth 2.0 Security Best Current Practice](https://tools.ietf.org/html/draft-ietf-oauth-security-topics-15#section-2.1)\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-352" ],
            "description" : "Using a constant value for the `state` in the OAuth 2.0 URL makes the application\n              susceptible to CSRF attacks.",
            "id" : "go/constant-oauth2-state",
            "kind" : "path-problem",
            "name" : "Use of constant `state` value in OAuth 2.0 URL",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "8.8"
          }
        }, {
          "id" : "go/disabled-certificate-check",
          "name" : "go/disabled-certificate-check",
          "shortDescription" : {
            "text" : "Disabled TLS certificate check"
          },
          "fullDescription" : {
            "text" : "If an application disables TLS certificate checking, it may be vulnerable to man-in-the-middle attacks."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "warning"
          },
          "help" : {
            "text" : "# Disabled TLS certificate check\nThe field `InsecureSkipVerify` controls whether a TLS client verifies the server's certificate chain and host name. If set to `true`, the client will accept any certificate and any host name in that certificate, making it susceptible to man-in-the-middle attacks.\n\n\n## Recommendation\nDo not set `InsecureSkipVerify` to `true` except in tests.\n\n\n## Example\nThe following code snippet shows a function that performs an HTTP request over TLS with certificate verification disabled:\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"net/http\"\n)\n\nfunc doAuthReq(authReq *http.Request) *http.Response {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\tclient := &http.Client{Transport: tr}\n\tres, _ := client.Do(authReq)\n\treturn res\n}\n\n```\nWhile this is acceptable in a test, it should not be used in production code. Instead, certificates should be configured such that verification can be performed.\n\n\n## References\n* Package tls: [Config](https://golang.org/pkg/crypto/tls/#Config).\n* SSL.com: [Browsers and Certificate Validation](https://www.ssl.com/article/browsers-and-certificate-validation/).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n",
            "markdown" : "# Disabled TLS certificate check\nThe field `InsecureSkipVerify` controls whether a TLS client verifies the server's certificate chain and host name. If set to `true`, the client will accept any certificate and any host name in that certificate, making it susceptible to man-in-the-middle attacks.\n\n\n## Recommendation\nDo not set `InsecureSkipVerify` to `true` except in tests.\n\n\n## Example\nThe following code snippet shows a function that performs an HTTP request over TLS with certificate verification disabled:\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"net/http\"\n)\n\nfunc doAuthReq(authReq *http.Request) *http.Response {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\tclient := &http.Client{Transport: tr}\n\tres, _ := client.Do(authReq)\n\treturn res\n}\n\n```\nWhile this is acceptable in a test, it should not be used in production code. Instead, certificates should be configured such that verification can be performed.\n\n\n## References\n* Package tls: [Config](https://golang.org/pkg/crypto/tls/#Config).\n* SSL.com: [Browsers and Certificate Validation](https://www.ssl.com/article/browsers-and-certificate-validation/).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-295" ],
            "description" : "If an application disables TLS certificate checking, it may be vulnerable to\n              man-in-the-middle attacks.",
            "id" : "go/disabled-certificate-check",
            "kind" : "problem",
            "name" : "Disabled TLS certificate check",
            "precision" : "high",
            "problem.severity" : "warning",
            "security-severity" : "7.5"
          }
        }, {
          "id" : "go/bad-redirect-check",
          "name" : "go/bad-redirect-check",
          "shortDescription" : {
            "text" : "Bad redirect check"
          },
          "fullDescription" : {
            "text" : "A redirect check that checks for a leading slash but not two leading slashes or a leading slash followed by a backslash is incomplete."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# Bad redirect check\nRedirect URLs should be checked to ensure that user input cannot cause a site to redirect to arbitrary domains. This is often done with a check that the redirect URL begins with a slash, which most of the time is an absolute redirect on the same host. However, browsers interpret URLs beginning with `//` or `/\\` as absolute URLs. For example, a redirect to `//example.com` will redirect to `https://example.com`. Thus, redirect checks must also check the second character of redirect URLs.\n\n\n## Recommendation\nAlso disallow redirect URLs starting with `//` or `/\\`.\n\n\n## Example\nThe following function validates a (presumably untrusted) redirect URL `redir`. If it does not begin with `/`, the harmless placeholder redirect URL `/` is returned to prevent an open redirect; otherwise `redir` itself is returned.\n\n\n```go\npackage main\n\nfunc sanitizeUrl(redir string) string {\n\tif len(redir) > 0 && redir[0] == '/' {\n\t\treturn redir\n\t}\n\treturn \"/\"\n}\n\n```\nWhile this check provides partial protection, it should be extended to cover `//` and `/\\` as well:\n\n\n```go\npackage main\n\nfunc sanitizeUrl1(redir string) string {\n\tif len(redir) > 1 && redir[0] == '/' && redir[1] != '/' && redir[1] != '\\\\' {\n\t\treturn redir\n\t}\n\treturn \"/\"\n}\n\n```\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html#validating-urls).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n",
            "markdown" : "# Bad redirect check\nRedirect URLs should be checked to ensure that user input cannot cause a site to redirect to arbitrary domains. This is often done with a check that the redirect URL begins with a slash, which most of the time is an absolute redirect on the same host. However, browsers interpret URLs beginning with `//` or `/\\` as absolute URLs. For example, a redirect to `//example.com` will redirect to `https://example.com`. Thus, redirect checks must also check the second character of redirect URLs.\n\n\n## Recommendation\nAlso disallow redirect URLs starting with `//` or `/\\`.\n\n\n## Example\nThe following function validates a (presumably untrusted) redirect URL `redir`. If it does not begin with `/`, the harmless placeholder redirect URL `/` is returned to prevent an open redirect; otherwise `redir` itself is returned.\n\n\n```go\npackage main\n\nfunc sanitizeUrl(redir string) string {\n\tif len(redir) > 0 && redir[0] == '/' {\n\t\treturn redir\n\t}\n\treturn \"/\"\n}\n\n```\nWhile this check provides partial protection, it should be extended to cover `//` and `/\\` as well:\n\n\n```go\npackage main\n\nfunc sanitizeUrl1(redir string) string {\n\tif len(redir) > 1 && redir[0] == '/' && redir[1] != '/' && redir[1] != '\\\\' {\n\t\treturn redir\n\t}\n\treturn \"/\"\n}\n\n```\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html#validating-urls).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-601" ],
            "description" : "A redirect check that checks for a leading slash but not two\n              leading slashes or a leading slash followed by a backslash is\n              incomplete.",
            "id" : "go/bad-redirect-check",
            "kind" : "path-problem",
            "name" : "Bad redirect check",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "6.1"
          }
        }, {
          "id" : "go/unvalidated-url-redirection",
          "name" : "go/unvalidated-url-redirection",
          "shortDescription" : {
            "text" : "Open URL redirect"
          },
          "fullDescription" : {
            "text" : "Open URL redirection based on unvalidated user input may cause redirection to malicious web sites."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "warning"
          },
          "help" : {
            "text" : "# Open URL redirect\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n)\n\nfunc serve() {\n\thttp.HandleFunc(\"/redir\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\thttp.Redirect(w, r, r.Form.Get(\"target\"), 302)\n\t})\n}\n\n```\nOne way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc serve() {\n\thttp.HandleFunc(\"/redir\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\ttarget, err := url.Parse(r.Form.Get(\"target\"))\n\t\tif err != nil {\n\t\t\t// ...\n\t\t}\n\n\t\tif target.Hostname() == \"semmle.com\" {\n\t\t\t// GOOD: checking hostname\n\t\t\thttp.Redirect(w, r, target.String(), 302)\n\t\t} else {\n\t\t\thttp.WriteHeader(400)\n\t\t}\n\t})\n}\n\n```\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n",
            "markdown" : "# Open URL redirect\nDirectly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but is controlled by the attacker.\n\n\n## Recommendation\nTo guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n)\n\nfunc serve() {\n\thttp.HandleFunc(\"/redir\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\thttp.Redirect(w, r, r.Form.Get(\"target\"), 302)\n\t})\n}\n\n```\nOne way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"net/url\"\n)\n\nfunc serve() {\n\thttp.HandleFunc(\"/redir\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\ttarget, err := url.Parse(r.Form.Get(\"target\"))\n\t\tif err != nil {\n\t\t\t// ...\n\t\t}\n\n\t\tif target.Hostname() == \"semmle.com\" {\n\t\t\t// GOOD: checking hostname\n\t\t\thttp.Redirect(w, r, target.String(), 302)\n\t\t} else {\n\t\t\thttp.WriteHeader(400)\n\t\t}\n\t})\n}\n\n```\n\n## References\n* OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-601" ],
            "description" : "Open URL redirection based on unvalidated user input\n              may cause redirection to malicious web sites.",
            "id" : "go/unvalidated-url-redirection",
            "kind" : "path-problem",
            "name" : "Open URL redirect",
            "precision" : "high",
            "problem.severity" : "warning",
            "security-severity" : "6.1"
          }
        }, {
          "id" : "go/reflected-xss",
          "name" : "go/reflected-xss",
          "shortDescription" : {
            "text" : "Reflected cross-site scripting"
          },
          "fullDescription" : {
            "text" : "Writing user input directly to an HTTP response allows for a cross-site scripting vulnerability."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# Reflected cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to an HTTP response without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *reflected* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the response, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example code writes part of an HTTP request (which is controlled by the user) directly to the response. This leaves the website vulnerable to cross-site scripting.\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc serve() {\n\thttp.HandleFunc(\"/user\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tusername := r.Form.Get(\"username\")\n\t\tif !isValidUsername(username) {\n\t\t\t// BAD: a request parameter is incorporated without validation into the response\n\t\t\tfmt.Fprintf(w, \"%q is an unknown user\", username)\n\t\t} else {\n\t\t\t// TODO: Handle successful login\n\t\t}\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\nSanitizing the user-controlled data prevents the vulnerability:\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"html\"\n\t\"net/http\"\n)\n\nfunc serve1() {\n\thttp.HandleFunc(\"/user\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tusername := r.Form.Get(\"username\")\n\t\tif !isValidUsername(username) {\n\t\t\t// GOOD: a request parameter is escaped before being put into the response\n\t\t\tfmt.Fprintf(w, \"%q is an unknown user\", html.EscapeString(username))\n\t\t} else {\n\t\t\t// TODO: do something exciting\n\t\t}\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
            "markdown" : "# Reflected cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to an HTTP response without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *reflected* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the response, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example code writes part of an HTTP request (which is controlled by the user) directly to the response. This leaves the website vulnerable to cross-site scripting.\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc serve() {\n\thttp.HandleFunc(\"/user\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tusername := r.Form.Get(\"username\")\n\t\tif !isValidUsername(username) {\n\t\t\t// BAD: a request parameter is incorporated without validation into the response\n\t\t\tfmt.Fprintf(w, \"%q is an unknown user\", username)\n\t\t} else {\n\t\t\t// TODO: Handle successful login\n\t\t}\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\nSanitizing the user-controlled data prevents the vulnerability:\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"html\"\n\t\"net/http\"\n)\n\nfunc serve1() {\n\thttp.HandleFunc(\"/user\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tusername := r.Form.Get(\"username\")\n\t\tif !isValidUsername(username) {\n\t\t\t// GOOD: a request parameter is escaped before being put into the response\n\t\t\tfmt.Fprintf(w, \"%q is an unknown user\", html.EscapeString(username))\n\t\t} else {\n\t\t\t// TODO: do something exciting\n\t\t}\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-079", "external/cwe/cwe-116" ],
            "description" : "Writing user input directly to an HTTP response allows for\n              a cross-site scripting vulnerability.",
            "id" : "go/reflected-xss",
            "kind" : "path-problem",
            "name" : "Reflected cross-site scripting",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "6.1"
          }
        }, {
          "id" : "go/xml/xpath-injection",
          "name" : "go/xml/xpath-injection",
          "shortDescription" : {
            "text" : "XPath injection"
          },
          "fullDescription" : {
            "text" : "Building an XPath expression from user-controlled sources is vulnerable to insertion of malicious code by the user."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# XPath injection\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, pre-compile the query and use variable references to include the user input.\n\nFor example, when using the `github.com/ChrisTrenkamp/goxpath` API, you can do this by creating a function that takes an `*goxpath.Opts` structure. In this structure you can then set the values of the variable references. This function can then be specified when calling `Exec()`, `Exec{Bool|Num|Node}()`, `ParseExec()`, or `MustExec()`.\n\n\n## Example\nIn the first example, the code accepts a username specified by the user, and uses this unvalidated and unsanitized value in an XPath expression. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.\n\nIn the second example, the XPath expression is a hard-coded string that specifies some variables, which are safely resolved at runtime using the `goxpath.Opts` structure.\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/ChrisTrenkamp/goxpath\"\n\t\"github.com/ChrisTrenkamp/goxpath/tree\"\n)\n\nfunc main() {}\n\nfunc processRequest(r *http.Request, doc tree.Node) {\n\tr.ParseForm()\n\tusername := r.Form.Get(\"username\")\n\n\t// BAD: User input used directly in an XPath expression\n\txPath := goxpath.MustParse(\"//users/user[login/text()='\" + username + \"']/home_dir/text()\")\n\tunsafeRes, _ := xPath.ExecBool(doc)\n\tfmt.Println(unsafeRes)\n\n\t// GOOD: Value of parameters is defined here instead of directly in the query\n\topt := func(o *goxpath.Opts) {\n\t\to.Vars[\"username\"] = tree.String(username)\n\t}\n\t// GOOD: Uses parameters to avoid including user input directly in XPath expression\n\txPath = goxpath.MustParse(\"//users/user[login/text()=$username]/home_dir/text()\")\n\tsafeRes, _ := xPath.ExecBool(doc, opt)\n\tfmt.Println(safeRes)\n}\n\n```\n\n## References\n* OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).\n* OWASP: [XPath Injection](https://www.owasp.org/index.php/XPATH_Injection).\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n",
            "markdown" : "# XPath injection\nIf an XPath expression is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to create a malicious XPath expression.\n\n\n## Recommendation\nIf user input must be included in an XPath expression, pre-compile the query and use variable references to include the user input.\n\nFor example, when using the `github.com/ChrisTrenkamp/goxpath` API, you can do this by creating a function that takes an `*goxpath.Opts` structure. In this structure you can then set the values of the variable references. This function can then be specified when calling `Exec()`, `Exec{Bool|Num|Node}()`, `ParseExec()`, or `MustExec()`.\n\n\n## Example\nIn the first example, the code accepts a username specified by the user, and uses this unvalidated and unsanitized value in an XPath expression. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.\n\nIn the second example, the XPath expression is a hard-coded string that specifies some variables, which are safely resolved at runtime using the `goxpath.Opts` structure.\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/ChrisTrenkamp/goxpath\"\n\t\"github.com/ChrisTrenkamp/goxpath/tree\"\n)\n\nfunc main() {}\n\nfunc processRequest(r *http.Request, doc tree.Node) {\n\tr.ParseForm()\n\tusername := r.Form.Get(\"username\")\n\n\t// BAD: User input used directly in an XPath expression\n\txPath := goxpath.MustParse(\"//users/user[login/text()='\" + username + \"']/home_dir/text()\")\n\tunsafeRes, _ := xPath.ExecBool(doc)\n\tfmt.Println(unsafeRes)\n\n\t// GOOD: Value of parameters is defined here instead of directly in the query\n\topt := func(o *goxpath.Opts) {\n\t\to.Vars[\"username\"] = tree.String(username)\n\t}\n\t// GOOD: Uses parameters to avoid including user input directly in XPath expression\n\txPath = goxpath.MustParse(\"//users/user[login/text()=$username]/home_dir/text()\")\n\tsafeRes, _ := xPath.ExecBool(doc, opt)\n\tfmt.Println(safeRes)\n}\n\n```\n\n## References\n* OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).\n* OWASP: [XPath Injection](https://www.owasp.org/index.php/XPATH_Injection).\n* Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-643" ],
            "description" : "Building an XPath expression from user-controlled sources is vulnerable to insertion of\n              malicious code by the user.",
            "id" : "go/xml/xpath-injection",
            "kind" : "path-problem",
            "name" : "XPath injection",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "9.8"
          }
        }, {
          "id" : "go/unsafe-quoting",
          "name" : "go/unsafe-quoting",
          "shortDescription" : {
            "text" : "Potentially unsafe quoting"
          },
          "fullDescription" : {
            "text" : "If a quoted string literal is constructed from data that may itself contain quotes, the embedded data could (accidentally or intentionally) change the structure of the overall string."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "warning"
          },
          "help" : {
            "text" : "# Potentially unsafe quoting\nCode that constructs a string containing a quoted substring needs to ensure that any user-provided data embedded in between the quotes does not itself contain a quote. Otherwise the embedded data could (accidentally or intentionally) change the structure of the overall string by terminating the quoted substring early, with potentially severe consequences. If, for example, the string is later interpreted as an operating-system command or database query, a malicious attacker may be able to craft input data that enables a command injection or SQL injection attack.\n\n\n## Recommendation\nSanitize the embedded data appropriately to ensure quotes are escaped, or use an API that does not rely on manually constructing quoted substrings.\n\n\n## Example\nIn the following example, assume that `version` is an object from an untrusted source. The code snippet first uses `json.Marshal` to serialize this object into a string, and then embeds it into a SQL query built using the Squirrel library.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\tsq \"github.com/Masterminds/squirrel\"\n)\n\nfunc save(id string, version interface{}) {\n\tversionJSON, _ := json.Marshal(version)\n\tsq.StatementBuilder.\n\t\tInsert(\"resources\").\n\t\tColumns(\"resource_id\", \"version_md5\").\n\t\tValues(id, sq.Expr(fmt.Sprintf(\"md5('%s')\", versionJSON))).\n\t\tExec()\n}\n\n```\nNote that while Squirrel provides a structured API for building SQL queries that mitigates against common causes of SQL injection vulnerabilities, this code is still vulnerable: if the JSON-encoded representation of `version` contains a single quote, this will prematurely close the surrounding string, changing the structure of the SQL expression being constructed. This could be exploited to mount a SQL injection attack.\n\nTo fix this vulnerability, use Squirrel's placeholder syntax, which avoids the need to explicitly construct a quoted string.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\tsq \"github.com/Masterminds/squirrel\"\n)\n\nfunc saveGood(id string, version interface{}) {\n\tversionJSON, _ := json.Marshal(version)\n\tsq.StatementBuilder.\n\t\tInsert(\"resources\").\n\t\tColumns(\"resource_id\", \"version_md5\").\n\t\tValues(id, sq.Expr(\"md5(?)\", versionJSON)).\n\t\tExec()\n}\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n",
            "markdown" : "# Potentially unsafe quoting\nCode that constructs a string containing a quoted substring needs to ensure that any user-provided data embedded in between the quotes does not itself contain a quote. Otherwise the embedded data could (accidentally or intentionally) change the structure of the overall string by terminating the quoted substring early, with potentially severe consequences. If, for example, the string is later interpreted as an operating-system command or database query, a malicious attacker may be able to craft input data that enables a command injection or SQL injection attack.\n\n\n## Recommendation\nSanitize the embedded data appropriately to ensure quotes are escaped, or use an API that does not rely on manually constructing quoted substrings.\n\n\n## Example\nIn the following example, assume that `version` is an object from an untrusted source. The code snippet first uses `json.Marshal` to serialize this object into a string, and then embeds it into a SQL query built using the Squirrel library.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\tsq \"github.com/Masterminds/squirrel\"\n)\n\nfunc save(id string, version interface{}) {\n\tversionJSON, _ := json.Marshal(version)\n\tsq.StatementBuilder.\n\t\tInsert(\"resources\").\n\t\tColumns(\"resource_id\", \"version_md5\").\n\t\tValues(id, sq.Expr(fmt.Sprintf(\"md5('%s')\", versionJSON))).\n\t\tExec()\n}\n\n```\nNote that while Squirrel provides a structured API for building SQL queries that mitigates against common causes of SQL injection vulnerabilities, this code is still vulnerable: if the JSON-encoded representation of `version` contains a single quote, this will prematurely close the surrounding string, changing the structure of the SQL expression being constructed. This could be exploited to mount a SQL injection attack.\n\nTo fix this vulnerability, use Squirrel's placeholder syntax, which avoids the need to explicitly construct a quoted string.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\tsq \"github.com/Masterminds/squirrel\"\n)\n\nfunc saveGood(id string, version interface{}) {\n\tversionJSON, _ := json.Marshal(version)\n\tsq.StatementBuilder.\n\t\tInsert(\"resources\").\n\t\tColumns(\"resource_id\", \"version_md5\").\n\t\tValues(id, sq.Expr(\"md5(?)\", versionJSON)).\n\t\tExec()\n}\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
          },
          "properties" : {
            "tags" : [ "correctness", "security", "external/cwe/cwe-078", "external/cwe/cwe-089", "external/cwe/cwe-094" ],
            "description" : "If a quoted string literal is constructed from data that may itself contain quotes,\n              the embedded data could (accidentally or intentionally) change the structure of\n              the overall string.",
            "id" : "go/unsafe-quoting",
            "kind" : "path-problem",
            "name" : "Potentially unsafe quoting",
            "precision" : "high",
            "problem.severity" : "warning",
            "security-severity" : "9.3"
          }
        }, {
          "id" : "go/sql-injection",
          "name" : "go/sql-injection",
          "shortDescription" : {
            "text" : "Database query built from user-controlled sources"
          },
          "fullDescription" : {
            "text" : "Building a database query from user-controlled sources is vulnerable to insertion of malicious code by the user."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# Database query built from user-controlled sources\nIf a database query (such as an SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run commands that exfiltrate, tamper with, or destroy data stored in the database.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements. Use these features rather than building queries by string concatenation.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object:\n\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(db *sql.DB, req *http.Request) {\n\tq := fmt.Sprintf(\"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='%s' ORDER BY PRICE\",\n\t\treq.URL.Query()[\"category\"])\n\tdb.Query(q)\n}\n\n```\nThe handler constructs an SQL query involving user input taken from the request object unsafely using `fmt.Sprintf` to embed a request parameter directly into the query string `q`. The parameter may include quote characters, allowing a malicious user to terminate the string literal into which the parameter is embedded and add arbitrary SQL code after it.\n\nInstead, the untrusted query parameter should be safely embedded using placeholder parameters:\n\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"net/http\"\n)\n\nfunc handlerGood(db *sql.DB, req *http.Request) {\n\tq := \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='?' ORDER BY PRICE\"\n\tdb.Query(q, req.URL.Query()[\"category\"])\n}\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n",
            "markdown" : "# Database query built from user-controlled sources\nIf a database query (such as an SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run commands that exfiltrate, tamper with, or destroy data stored in the database.\n\n\n## Recommendation\nMost database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements. Use these features rather than building queries by string concatenation.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object:\n\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(db *sql.DB, req *http.Request) {\n\tq := fmt.Sprintf(\"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='%s' ORDER BY PRICE\",\n\t\treq.URL.Query()[\"category\"])\n\tdb.Query(q)\n}\n\n```\nThe handler constructs an SQL query involving user input taken from the request object unsafely using `fmt.Sprintf` to embed a request parameter directly into the query string `q`. The parameter may include quote characters, allowing a malicious user to terminate the string literal into which the parameter is embedded and add arbitrary SQL code after it.\n\nInstead, the untrusted query parameter should be safely embedded using placeholder parameters:\n\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"net/http\"\n)\n\nfunc handlerGood(db *sql.DB, req *http.Request) {\n\tq := \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='?' ORDER BY PRICE\"\n\tdb.Query(q, req.URL.Query()[\"category\"])\n}\n\n```\n\n## References\n* Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-089" ],
            "description" : "Building a database query from user-controlled sources is vulnerable to insertion of\n              malicious code by the user.",
            "id" : "go/sql-injection",
            "kind" : "path-problem",
            "name" : "Database query built from user-controlled sources",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "8.8"
          }
        }, {
          "id" : "go/email-injection",
          "name" : "go/email-injection",
          "shortDescription" : {
            "text" : "Email content injection"
          },
          "fullDescription" : {
            "text" : "Incorporating untrusted input directly into an email message can enable content spoofing, which in turn may lead to information leaks and other security issues."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# Email content injection\nUsing untrusted input to construct an email can cause multiple security vulnerabilities. For instance, inclusion of an untrusted input in an email body may allow an attacker to conduct cross-site scripting (XSS) attacks, while inclusion of an HTTP header may allow a full account compromise as shown in the example below.\n\n\n## Recommendation\nAny data which is passed to an email subject or body must be sanitized before use.\n\n\n## Example\nIn the following example snippet, the `host` field is user controlled.\n\nA malicious user can send an HTTP request to the targeted website, but with a Host header that refers to their own website. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious website.\n\nIf the email contains a password reset link, and the victim clicks the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"net/smtp\"\n)\n\nfunc mail(w http.ResponseWriter, r *http.Request) {\n\thost := r.Header.Get(\"Host\")\n\ttoken := backend.getUserSecretResetToken(email)\n\tbody := \"Click to reset password: \" + host + \"/\" + token\n\tsmtp.SendMail(\"test.test\", nil, \"from@from.com\", nil, []byte(body))\n}\n\n```\nOne way to prevent this is to load the host name from a trusted configuration file instead.\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"net/smtp\"\n)\n\nfunc mailGood(w http.ResponseWriter, r *http.Request) {\n\thost := config.Get(\"Host\")\n\ttoken := backend.getUserSecretResetToken(email)\n\tbody := \"Click to reset password: \" + host + \"/\" + token\n\tsmtp.SendMail(\"test.test\", nil, \"from@from.com\", nil, []byte(body))\n}\n\n```\n\n## References\n* OWASP: [Content Spoofing](https://owasp.org/www-community/attacks/Content_Spoofing) .\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\n",
            "markdown" : "# Email content injection\nUsing untrusted input to construct an email can cause multiple security vulnerabilities. For instance, inclusion of an untrusted input in an email body may allow an attacker to conduct cross-site scripting (XSS) attacks, while inclusion of an HTTP header may allow a full account compromise as shown in the example below.\n\n\n## Recommendation\nAny data which is passed to an email subject or body must be sanitized before use.\n\n\n## Example\nIn the following example snippet, the `host` field is user controlled.\n\nA malicious user can send an HTTP request to the targeted website, but with a Host header that refers to their own website. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious website.\n\nIf the email contains a password reset link, and the victim clicks the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"net/smtp\"\n)\n\nfunc mail(w http.ResponseWriter, r *http.Request) {\n\thost := r.Header.Get(\"Host\")\n\ttoken := backend.getUserSecretResetToken(email)\n\tbody := \"Click to reset password: \" + host + \"/\" + token\n\tsmtp.SendMail(\"test.test\", nil, \"from@from.com\", nil, []byte(body))\n}\n\n```\nOne way to prevent this is to load the host name from a trusted configuration file instead.\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"net/smtp\"\n)\n\nfunc mailGood(w http.ResponseWriter, r *http.Request) {\n\thost := config.Get(\"Host\")\n\ttoken := backend.getUserSecretResetToken(email)\n\tbody := \"Click to reset password: \" + host + \"/\" + token\n\tsmtp.SendMail(\"test.test\", nil, \"from@from.com\", nil, []byte(body))\n}\n\n```\n\n## References\n* OWASP: [Content Spoofing](https://owasp.org/www-community/attacks/Content_Spoofing) .\n* Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-640" ],
            "description" : "Incorporating untrusted input directly into an email message can enable\n              content spoofing, which in turn may lead to information leaks and other\n              security issues.",
            "id" : "go/email-injection",
            "kind" : "path-problem",
            "name" : "Email content injection",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "9.8"
          }
        }, {
          "id" : "go/clear-text-logging",
          "name" : "go/clear-text-logging",
          "shortDescription" : {
            "text" : "Clear-text logging of sensitive information"
          },
          "fullDescription" : {
            "text" : "Logging sensitive information without encryption or hashing can expose it to an attacker."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# Clear-text logging of sensitive information\nSensitive information that is logged unencrypted is accessible to an attacker who gains access to the logs.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted or obfuscated before being logged.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the standard out and standard error streams of the application, causing logged sensitive information to be stored.\n\n\n## Example\nThe following example code logs user credentials (in this case, their password) in plain text:\n\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc serve() {\n\thttp.HandleFunc(\"/register\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tuser := r.Form.Get(\"user\")\n\t\tpw := r.Form.Get(\"password\")\n\n\t\tlog.Printf(\"Registering new user %s with password %s.\\n\", user, pw)\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\nInstead, the credentials should be encrypted, obfuscated, or omitted entirely:\n\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc serve1() {\n\thttp.HandleFunc(\"/register\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tuser := r.Form.Get(\"user\")\n\t\tpw := r.Form.Get(\"password\")\n\n\t\tlog.Printf(\"Registering new user %s.\\n\", user)\n\n\t\t// ...\n\t\tuse(pw)\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* OWASP: [Password Plaintext Storage](https://www.owasp.org/index.php/Password_Plaintext_Storage).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n",
            "markdown" : "# Clear-text logging of sensitive information\nSensitive information that is logged unencrypted is accessible to an attacker who gains access to the logs.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted or obfuscated before being logged.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the standard out and standard error streams of the application, causing logged sensitive information to be stored.\n\n\n## Example\nThe following example code logs user credentials (in this case, their password) in plain text:\n\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc serve() {\n\thttp.HandleFunc(\"/register\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tuser := r.Form.Get(\"user\")\n\t\tpw := r.Form.Get(\"password\")\n\n\t\tlog.Printf(\"Registering new user %s with password %s.\\n\", user, pw)\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\nInstead, the credentials should be encrypted, obfuscated, or omitted entirely:\n\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc serve1() {\n\thttp.HandleFunc(\"/register\", func(w http.ResponseWriter, r *http.Request) {\n\t\tr.ParseForm()\n\t\tuser := r.Form.Get(\"user\")\n\t\tpw := r.Form.Get(\"password\")\n\n\t\tlog.Printf(\"Registering new user %s.\\n\", user)\n\n\t\t// ...\n\t\tuse(pw)\n\t})\n\thttp.ListenAndServe(\":80\", nil)\n}\n\n```\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* OWASP: [Password Plaintext Storage](https://www.owasp.org/index.php/Password_Plaintext_Storage).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-312", "external/cwe/cwe-315", "external/cwe/cwe-359" ],
            "description" : "Logging sensitive information without encryption or hashing can\n              expose it to an attacker.",
            "id" : "go/clear-text-logging",
            "kind" : "path-problem",
            "name" : "Clear-text logging of sensitive information",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "7.5"
          }
        }, {
          "id" : "go/regex/missing-regexp-anchor",
          "name" : "go/regex/missing-regexp-anchor",
          "shortDescription" : {
            "text" : "Missing regular expression anchor"
          },
          "fullDescription" : {
            "text" : "Regular expressions without anchors can be vulnerable to bypassing."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "warning"
          },
          "help" : {
            "text" : "# Missing regular expression anchor\nSanitizing untrusted input with regular expressions is a common technique. However, it is error-prone to match untrusted input against regular expressions without anchors such as `^` or `$`. Malicious input can bypass such security checks by embedding one of the allowed patterns in an unexpected location.\n\nEven if the matching is not done in a security-critical context, it may still cause undesirable behavior when the regular expression accidentally matches.\n\n\n## Recommendation\nUse anchors to ensure that regular expressions match at the expected locations.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.\n\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\nfunc checkRedirect2(req *http.Request, via []*http.Request) error {\n\t// BAD: the host of `req.URL` may be controlled by an attacker\n\tre := \"https?://www\\\\.example\\\\.com/\"\n\tif matched, _ := regexp.MatchString(re, req.URL.String()); matched {\n\t\treturn nil\n\t}\n\treturn errors.New(\"Invalid redirect\")\n}\n\n```\nThe check with the regular expression match is, however, easy to bypass. For example, the string `http://example.com/` can be embedded in the query string component: `http://evil-example.net/?x=http://example.com/`.\n\nAddress these shortcomings by using anchors in the regular expression instead:\n\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\nfunc checkRedirect2Good(req *http.Request, via []*http.Request) error {\n\t// GOOD: the host of `req.URL` cannot be controlled by an attacker\n\tre := \"^https?://www\\\\.example\\\\.com/\"\n\tif matched, _ := regexp.MatchString(re, req.URL.String()); matched {\n\t\treturn nil\n\t}\n\treturn errors.New(\"Invalid redirect\")\n}\n\n```\nA related mistake is to write a regular expression with multiple alternatives, but to only anchor one of the alternatives. As an example, the regular expression `^www\\.example\\.com|beta\\.example\\.com` will match the host `evil.beta.example.com` because the regular expression is parsed as `(^www\\.example\\.com)|(beta\\.example\\.com)/`, so the second alternative `beta\\.example\\.com` is not anchored at the beginning of the string.\n\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n",
            "markdown" : "# Missing regular expression anchor\nSanitizing untrusted input with regular expressions is a common technique. However, it is error-prone to match untrusted input against regular expressions without anchors such as `^` or `$`. Malicious input can bypass such security checks by embedding one of the allowed patterns in an unexpected location.\n\nEven if the matching is not done in a security-critical context, it may still cause undesirable behavior when the regular expression accidentally matches.\n\n\n## Recommendation\nUse anchors to ensure that regular expressions match at the expected locations.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.\n\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\nfunc checkRedirect2(req *http.Request, via []*http.Request) error {\n\t// BAD: the host of `req.URL` may be controlled by an attacker\n\tre := \"https?://www\\\\.example\\\\.com/\"\n\tif matched, _ := regexp.MatchString(re, req.URL.String()); matched {\n\t\treturn nil\n\t}\n\treturn errors.New(\"Invalid redirect\")\n}\n\n```\nThe check with the regular expression match is, however, easy to bypass. For example, the string `http://example.com/` can be embedded in the query string component: `http://evil-example.net/?x=http://example.com/`.\n\nAddress these shortcomings by using anchors in the regular expression instead:\n\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\nfunc checkRedirect2Good(req *http.Request, via []*http.Request) error {\n\t// GOOD: the host of `req.URL` cannot be controlled by an attacker\n\tre := \"^https?://www\\\\.example\\\\.com/\"\n\tif matched, _ := regexp.MatchString(re, req.URL.String()); matched {\n\t\treturn nil\n\t}\n\treturn errors.New(\"Invalid redirect\")\n}\n\n```\nA related mistake is to write a regular expression with multiple alternatives, but to only anchor one of the alternatives. As an example, the regular expression `^www\\.example\\.com|beta\\.example\\.com` will match the host `evil.beta.example.com` because the regular expression is parsed as `(^www\\.example\\.com)|(beta\\.example\\.com)/`, so the second alternative `beta\\.example\\.com` is not anchored at the beginning of the string.\n\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
          },
          "properties" : {
            "tags" : [ "correctness", "security", "external/cwe/cwe-20" ],
            "description" : "Regular expressions without anchors can be vulnerable to bypassing.",
            "id" : "go/regex/missing-regexp-anchor",
            "kind" : "problem",
            "name" : "Missing regular expression anchor",
            "precision" : "high",
            "problem.severity" : "warning",
            "security-severity" : "7.8"
          }
        }, {
          "id" : "go/incomplete-url-scheme-check",
          "name" : "go/incomplete-url-scheme-check",
          "shortDescription" : {
            "text" : "Incomplete URL scheme check"
          },
          "fullDescription" : {
            "text" : "Checking for the \"javascript:\" URL scheme without also checking for \"vbscript:\" and \"data:\" suggests a logic error or even a security vulnerability."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "warning"
          },
          "help" : {
            "text" : "# Incomplete URL scheme check\nURLs with the special scheme `javascript` can be used to encode JavaScript code to be executed when the URL is visited. While this is a powerful mechanism for creating feature-rich and responsive web applications, it is also a potential security risk: if the URL comes from an untrusted source, it might contain harmful JavaScript code. For this reason, many frameworks and libraries first check the URL scheme of any untrusted URL, and reject URLs with the `javascript` scheme.\n\nHowever, the `data` and `vbscript` schemes can be used to represent executable code in a very similar way, so any validation logic that checks against `javascript`, but not against `data` and `vbscript`, is likely to be insufficient.\n\n\n## Recommendation\nAdd checks covering both `data:` and `vbscript:`.\n\n\n## Example\nThe following function validates a (presumably untrusted) URL `urlstr`. If its scheme is `javascript`, the harmless placeholder URL `about:blank` is returned to prevent code injection; otherwise `urlstr` itself is returned.\n\n\n```go\npackage main\n\nimport \"net/url\"\n\nfunc sanitizeUrl(urlstr string) string {\n\tu, err := url.Parse(urlstr)\n\tif err != nil || u.Scheme == \"javascript\" {\n\t\treturn \"about:blank\"\n\t}\n\treturn urlstr\n}\n\n```\nWhile this check provides partial projection, it should be extended to cover `data` and `vbscript` as well:\n\n\n```go\npackage main\n\nimport \"net/url\"\n\nfunc sanitizeUrlGod(urlstr string) string {\n\tu, err := url.Parse(urlstr)\n\tif err != nil || u.Scheme == \"javascript\" || u.Scheme == \"data\" || u.Scheme == \"vbscript\" {\n\t\treturn \"about:blank\"\n\t}\n\treturn urlstr\n}\n\n```\n\n## References\n* WHATWG: [URL schemes](https://wiki.whatwg.org/wiki/URL_schemes).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n",
            "markdown" : "# Incomplete URL scheme check\nURLs with the special scheme `javascript` can be used to encode JavaScript code to be executed when the URL is visited. While this is a powerful mechanism for creating feature-rich and responsive web applications, it is also a potential security risk: if the URL comes from an untrusted source, it might contain harmful JavaScript code. For this reason, many frameworks and libraries first check the URL scheme of any untrusted URL, and reject URLs with the `javascript` scheme.\n\nHowever, the `data` and `vbscript` schemes can be used to represent executable code in a very similar way, so any validation logic that checks against `javascript`, but not against `data` and `vbscript`, is likely to be insufficient.\n\n\n## Recommendation\nAdd checks covering both `data:` and `vbscript:`.\n\n\n## Example\nThe following function validates a (presumably untrusted) URL `urlstr`. If its scheme is `javascript`, the harmless placeholder URL `about:blank` is returned to prevent code injection; otherwise `urlstr` itself is returned.\n\n\n```go\npackage main\n\nimport \"net/url\"\n\nfunc sanitizeUrl(urlstr string) string {\n\tu, err := url.Parse(urlstr)\n\tif err != nil || u.Scheme == \"javascript\" {\n\t\treturn \"about:blank\"\n\t}\n\treturn urlstr\n}\n\n```\nWhile this check provides partial projection, it should be extended to cover `data` and `vbscript` as well:\n\n\n```go\npackage main\n\nimport \"net/url\"\n\nfunc sanitizeUrlGod(urlstr string) string {\n\tu, err := url.Parse(urlstr)\n\tif err != nil || u.Scheme == \"javascript\" || u.Scheme == \"data\" || u.Scheme == \"vbscript\" {\n\t\treturn \"about:blank\"\n\t}\n\treturn urlstr\n}\n\n```\n\n## References\n* WHATWG: [URL schemes](https://wiki.whatwg.org/wiki/URL_schemes).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "correctness", "external/cwe/cwe-020" ],
            "description" : "Checking for the \"javascript:\" URL scheme without also checking for \"vbscript:\"\n              and \"data:\" suggests a logic error or even a security vulnerability.",
            "id" : "go/incomplete-url-scheme-check",
            "kind" : "problem",
            "name" : "Incomplete URL scheme check",
            "precision" : "high",
            "problem.severity" : "warning",
            "security-severity" : "7.8"
          }
        }, {
          "id" : "go/incomplete-hostname-regexp",
          "name" : "go/incomplete-hostname-regexp",
          "shortDescription" : {
            "text" : "Incomplete regular expression for hostnames"
          },
          "fullDescription" : {
            "text" : "Matching a URL or hostname against a regular expression that contains an unescaped dot as part of the hostname might match more hostnames than expected."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "warning"
          },
          "help" : {
            "text" : "# Incomplete regular expression for hostnames\nSanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Often, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nIf a regular expression implements such a check, it is easy to accidentally make the check too permissive by not escaping regular-expression meta-characters such as `.`.\n\nEven if the check is not used in a security-critical context, the incomplete check may still cause undesirable behavior when it accidentally succeeds.\n\n\n## Recommendation\nEscape all meta-characters appropriately when constructing regular expressions for security checks, paying special attention to the `.` meta-character.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains.\n\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\nfunc checkRedirect(req *http.Request, via []*http.Request) error {\n\t// BAD: the host of `req.URL` may be controlled by an attacker\n\tre := \"^((www|beta).)?example.com/\"\n\tif matched, _ := regexp.MatchString(re, req.URL.Host); matched {\n\t\treturn nil\n\t}\n\treturn errors.New(\"Invalid redirect\")\n}\n\n```\nThe check is however easy to bypass because the unescaped `.` allows for any character before `example.com`, effectively allowing the redirect to go to an attacker-controlled domain such as `wwwXexample.com`.\n\nAddress this vulnerability by escaping `.` appropriately:\n\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\nfunc checkRedirectGood(req *http.Request, via []*http.Request) error {\n\t// GOOD: the host of `req.URL` must be `example.com`, `www.example.com` or `beta.example.com`\n\tre := \"^((www|beta)\\\\.)?example\\\\.com/\"\n\tif matched, _ := regexp.MatchString(re, req.URL.Host); matched {\n\t\treturn nil\n\t}\n\treturn errors.New(\"Invalid redirect\")\n}\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n",
            "markdown" : "# Incomplete regular expression for hostnames\nSanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Often, this is done by checking that the host of a URL is in a set of allowed hosts.\n\nIf a regular expression implements such a check, it is easy to accidentally make the check too permissive by not escaping regular-expression meta-characters such as `.`.\n\nEven if the check is not used in a security-critical context, the incomplete check may still cause undesirable behavior when it accidentally succeeds.\n\n\n## Recommendation\nEscape all meta-characters appropriately when constructing regular expressions for security checks, paying special attention to the `.` meta-character.\n\n\n## Example\nThe following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains.\n\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\nfunc checkRedirect(req *http.Request, via []*http.Request) error {\n\t// BAD: the host of `req.URL` may be controlled by an attacker\n\tre := \"^((www|beta).)?example.com/\"\n\tif matched, _ := regexp.MatchString(re, req.URL.Host); matched {\n\t\treturn nil\n\t}\n\treturn errors.New(\"Invalid redirect\")\n}\n\n```\nThe check is however easy to bypass because the unescaped `.` allows for any character before `example.com`, effectively allowing the redirect to go to an attacker-controlled domain such as `wwwXexample.com`.\n\nAddress this vulnerability by escaping `.` appropriately:\n\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"regexp\"\n)\n\nfunc checkRedirectGood(req *http.Request, via []*http.Request) error {\n\t// GOOD: the host of `req.URL` must be `example.com`, `www.example.com` or `beta.example.com`\n\tre := \"^((www|beta)\\\\.)?example\\\\.com/\"\n\tif matched, _ := regexp.MatchString(re, req.URL.Host); matched {\n\t\treturn nil\n\t}\n\treturn errors.New(\"Invalid redirect\")\n}\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* OWASP: [Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
          },
          "properties" : {
            "tags" : [ "correctness", "security", "external/cwe/cwe-20" ],
            "description" : "Matching a URL or hostname against a regular expression that contains an unescaped\n              dot as part of the hostname might match more hostnames than expected.",
            "id" : "go/incomplete-hostname-regexp",
            "kind" : "path-problem",
            "name" : "Incomplete regular expression for hostnames",
            "precision" : "high",
            "problem.severity" : "warning",
            "security-severity" : "7.8"
          }
        }, {
          "id" : "go/suspicious-character-in-regex",
          "name" : "go/suspicious-character-in-regex",
          "shortDescription" : {
            "text" : "Suspicious characters in a regular expression"
          },
          "fullDescription" : {
            "text" : "If a literal bell character or backspace appears in a regular expression, the start of text or word boundary may have been intended."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "warning"
          },
          "help" : {
            "text" : "# Suspicious characters in a regular expression\nWhen a character in a string literal or regular expression literal is preceded by a backslash, it is interpreted as part of an escape sequence. For example, the escape sequence `\\n` in a string literal corresponds to a single `newline` character, and not the `\\` and `n` characters. There are two Go escape sequences that could produce surprising results. First, `regexp.Compile(\"\\a\")` matches the bell character, whereas `regexp.Compile(\"\\\\A\")` matches the start of text and `regexp.Compile(\"\\\\a\")` is a Vim (but not Go) regular expression matching any alphabetic character. Second, `regexp.Compile(\"\\b\")` matches a backspace, whereas `regexp.Compile(\"\\\\b\")` matches the start of a word. Confusing one for the other could lead to a regular expression passing or failing much more often than expected, with potential security consequences. Note this is less of a problem than in some other languages because in Go, only valid escape sequences are accepted, both in an ordinary string (for example, `s := \"\\k\"` will not compile as there is no such escape sequence) and in regular expressions (for example, `regexp.MustCompile(\"\\\\k\")` will panic as `\\k` does not refer to a character class or other special token according to Go's regular expression grammar).\n\n\n## Recommendation\nEnsure that the right number of backslashes is used when escaping characters in strings and regular expressions.\n\n\n## Example\nThe following example code fails to check for a forbidden word in an input string:\n\n\n```go\npackage main\n\nimport \"regexp\"\n\nfunc broken(hostNames []byte) string {\n\tvar hostRe = regexp.MustCompile(\"\\bforbidden.host.org\")\n\tif hostRe.Match(hostNames) {\n\t\treturn \"Must not target forbidden.host.org\"\n\t} else {\n\t\t// This will be reached even if hostNames is exactly \"forbidden.host.org\",\n\t\t// because the literal backspace is not matched\n\t\treturn \"\"\n\t}\n}\n\n```\nThe check does not work, but can be fixed by escaping the backslash:\n\n\n```go\npackage main\n\nimport \"regexp\"\n\nfunc fixed(hostNames []byte) string {\n\tvar hostRe = regexp.MustCompile(`\\bforbidden.host.org`)\n\tif hostRe.Match(hostNames) {\n\t\treturn \"Must not target forbidden.host.org\"\n\t} else {\n\t\t// hostNames definitely doesn't contain a word \"forbidden.host.org\", as \"\\\\b\"\n\t\t// is the start-of-word anchor, not a literal backspace.\n\t\treturn \"\"\n\t}\n}\n\n```\nAlternatively, you can use backtick-delimited raw string literals. For example, the `\\b` in ``` regexp.Compile(`hello\\bworld`) ``` matches a word boundary, not a backspace character, as within backticks `\\b` is not an escape sequence.\n\n\n## References\n* golang.org: [Overview of the Regexp package](https://golang.org/pkg/regexp/).\n* Google: [Syntax of regular expressions accepted by RE2](https://github.com/google/re2/wiki/Syntax).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n",
            "markdown" : "# Suspicious characters in a regular expression\nWhen a character in a string literal or regular expression literal is preceded by a backslash, it is interpreted as part of an escape sequence. For example, the escape sequence `\\n` in a string literal corresponds to a single `newline` character, and not the `\\` and `n` characters. There are two Go escape sequences that could produce surprising results. First, `regexp.Compile(\"\\a\")` matches the bell character, whereas `regexp.Compile(\"\\\\A\")` matches the start of text and `regexp.Compile(\"\\\\a\")` is a Vim (but not Go) regular expression matching any alphabetic character. Second, `regexp.Compile(\"\\b\")` matches a backspace, whereas `regexp.Compile(\"\\\\b\")` matches the start of a word. Confusing one for the other could lead to a regular expression passing or failing much more often than expected, with potential security consequences. Note this is less of a problem than in some other languages because in Go, only valid escape sequences are accepted, both in an ordinary string (for example, `s := \"\\k\"` will not compile as there is no such escape sequence) and in regular expressions (for example, `regexp.MustCompile(\"\\\\k\")` will panic as `\\k` does not refer to a character class or other special token according to Go's regular expression grammar).\n\n\n## Recommendation\nEnsure that the right number of backslashes is used when escaping characters in strings and regular expressions.\n\n\n## Example\nThe following example code fails to check for a forbidden word in an input string:\n\n\n```go\npackage main\n\nimport \"regexp\"\n\nfunc broken(hostNames []byte) string {\n\tvar hostRe = regexp.MustCompile(\"\\bforbidden.host.org\")\n\tif hostRe.Match(hostNames) {\n\t\treturn \"Must not target forbidden.host.org\"\n\t} else {\n\t\t// This will be reached even if hostNames is exactly \"forbidden.host.org\",\n\t\t// because the literal backspace is not matched\n\t\treturn \"\"\n\t}\n}\n\n```\nThe check does not work, but can be fixed by escaping the backslash:\n\n\n```go\npackage main\n\nimport \"regexp\"\n\nfunc fixed(hostNames []byte) string {\n\tvar hostRe = regexp.MustCompile(`\\bforbidden.host.org`)\n\tif hostRe.Match(hostNames) {\n\t\treturn \"Must not target forbidden.host.org\"\n\t} else {\n\t\t// hostNames definitely doesn't contain a word \"forbidden.host.org\", as \"\\\\b\"\n\t\t// is the start-of-word anchor, not a literal backspace.\n\t\treturn \"\"\n\t}\n}\n\n```\nAlternatively, you can use backtick-delimited raw string literals. For example, the `\\b` in ``` regexp.Compile(`hello\\bworld`) ``` matches a word boundary, not a backspace character, as within backticks `\\b` is not an escape sequence.\n\n\n## References\n* golang.org: [Overview of the Regexp package](https://golang.org/pkg/regexp/).\n* Google: [Syntax of regular expressions accepted by RE2](https://github.com/google/re2/wiki/Syntax).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
          },
          "properties" : {
            "tags" : [ "correctness", "security", "external/cwe/cwe-20" ],
            "description" : "If a literal bell character or backspace appears in a regular expression, the start of text or word boundary may have been intended.",
            "id" : "go/suspicious-character-in-regex",
            "kind" : "path-problem",
            "name" : "Suspicious characters in a regular expression",
            "precision" : "high",
            "problem.severity" : "warning",
            "security-severity" : "7.8"
          }
        }, {
          "id" : "go/request-forgery",
          "name" : "go/request-forgery",
          "shortDescription" : {
            "text" : "Uncontrolled data used in network request"
          },
          "fullDescription" : {
            "text" : "Sending network requests with user-controlled data allows for request forgery attacks."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# Uncontrolled data used in network request\nDirectly incorporating user input into an HTTP request without validating the input can facilitate different kinds of request forgery attacks, where the attacker essentially controls the request. If the vulnerable request is in server-side code, then security mechanisms, such as external firewalls, can be bypassed. If the vulnerable request is in client-side code, then unsuspecting users can send malicious requests to other servers, potentially resulting in a DDOS attack.\n\n\n## Recommendation\nTo guard against request forgery, it is advisable to avoid putting user input directly into a network request. If a flexible network request mechanism is required, it is recommended to maintain a list of authorized request targets and choose from that list based on the user input provided.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL request without validating the input, which facilitates an SSRF attack. The request `http.Get(...)` is vulnerable since attackers can choose the value of `target` to be anything they want. For instance, the attacker can choose `\"internal.example.com/#\"` as the target, causing the URL used in the request to be `\"https://internal.example.com/#.example.com/data\"`.\n\nA request to `https://internal.example.com` may be problematic if that server is not meant to be directly accessible from the attacker's machine.\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, req *http.Request) {\n\ttarget := req.FormValue(\"target\")\n\n\t// BAD: `target` is controlled by the attacker\n\tresp, err := http.Get(\"https://\" + target + \".example.com/data/\")\n\tif err != nil {\n\t\t// error handling\n\t}\n\n\t// process request response\n\tuse(resp)\n}\n\n```\nOne way to remedy the problem is to use the user input to select a known fixed string before performing the request:\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n)\n\nfunc handler1(w http.ResponseWriter, req *http.Request) {\n\ttarget := req.FormValue(\"target\")\n\n\tvar subdomain string\n\tif target == \"EU\" {\n\t\tsubdomain = \"europe\"\n\t} else {\n\t\tsubdomain = \"world\"\n\t}\n\n\t// GOOD: `subdomain` is controlled by the server\n\tresp, err := http.Get(\"https://\" + subdomain + \".example.com/data/\")\n\tif err != nil {\n\t\t// error handling\n\t}\n\n\t// process request response\n\tuse(resp)\n}\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n",
            "markdown" : "# Uncontrolled data used in network request\nDirectly incorporating user input into an HTTP request without validating the input can facilitate different kinds of request forgery attacks, where the attacker essentially controls the request. If the vulnerable request is in server-side code, then security mechanisms, such as external firewalls, can be bypassed. If the vulnerable request is in client-side code, then unsuspecting users can send malicious requests to other servers, potentially resulting in a DDOS attack.\n\n\n## Recommendation\nTo guard against request forgery, it is advisable to avoid putting user input directly into a network request. If a flexible network request mechanism is required, it is recommended to maintain a list of authorized request targets and choose from that list based on the user input provided.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly in a URL request without validating the input, which facilitates an SSRF attack. The request `http.Get(...)` is vulnerable since attackers can choose the value of `target` to be anything they want. For instance, the attacker can choose `\"internal.example.com/#\"` as the target, causing the URL used in the request to be `\"https://internal.example.com/#.example.com/data\"`.\n\nA request to `https://internal.example.com` may be problematic if that server is not meant to be directly accessible from the attacker's machine.\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, req *http.Request) {\n\ttarget := req.FormValue(\"target\")\n\n\t// BAD: `target` is controlled by the attacker\n\tresp, err := http.Get(\"https://\" + target + \".example.com/data/\")\n\tif err != nil {\n\t\t// error handling\n\t}\n\n\t// process request response\n\tuse(resp)\n}\n\n```\nOne way to remedy the problem is to use the user input to select a known fixed string before performing the request:\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n)\n\nfunc handler1(w http.ResponseWriter, req *http.Request) {\n\ttarget := req.FormValue(\"target\")\n\n\tvar subdomain string\n\tif target == \"EU\" {\n\t\tsubdomain = \"europe\"\n\t} else {\n\t\tsubdomain = \"world\"\n\t}\n\n\t// GOOD: `subdomain` is controlled by the server\n\tresp, err := http.Get(\"https://\" + subdomain + \".example.com/data/\")\n\tif err != nil {\n\t\t// error handling\n\t}\n\n\t// process request response\n\tuse(resp)\n}\n\n```\n\n## References\n* OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-918" ],
            "description" : "Sending network requests with user-controlled data allows for request forgery attacks.",
            "id" : "go/request-forgery",
            "kind" : "path-problem",
            "name" : "Uncontrolled data used in network request",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "9.1"
          }
        }, {
          "id" : "go/stack-trace-exposure",
          "name" : "go/stack-trace-exposure",
          "shortDescription" : {
            "text" : "Information exposure through a stack trace"
          },
          "fullDescription" : {
            "text" : "Information from a stack trace propagates to an external user. Stack traces can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, a panic is handled in two different ways. In the first version, labeled BAD, a detailed stack trace is written to a user-facing HTTP response object, which may disclose sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```go\npackage example\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"runtime\"\n)\n\nfunc handlePanic(w http.ResponseWriter, r *http.Request) {\n\tbuf := make([]byte, 2<<16)\n\tbuf = buf[:runtime.Stack(buf, true)]\n\t// BAD: printing a stack trace back to the response\n\tw.Write(buf)\n\t// GOOD: logging the response to the server and sending\n\t// a more generic message.\n\tlog.Printf(\"Panic: %s\", buf)\n\tw.Write([]byte(\"An unexpected runtime error occurred\"))\n}\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n",
            "markdown" : "# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, a panic is handled in two different ways. In the first version, labeled BAD, a detailed stack trace is written to a user-facing HTTP response object, which may disclose sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```go\npackage example\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"runtime\"\n)\n\nfunc handlePanic(w http.ResponseWriter, r *http.Request) {\n\tbuf := make([]byte, 2<<16)\n\tbuf = buf[:runtime.Stack(buf, true)]\n\t// BAD: printing a stack trace back to the response\n\tw.Write(buf)\n\t// GOOD: logging the response to the server and sending\n\t// a more generic message.\n\tlog.Printf(\"Panic: %s\", buf)\n\tw.Write([]byte(\"An unexpected runtime error occurred\"))\n}\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-209", "external/cwe/cwe-497" ],
            "description" : "Information from a stack trace propagates to an external user.\n              Stack traces can unintentionally reveal implementation details\n              that are useful to an attacker for developing a subsequent exploit.",
            "id" : "go/stack-trace-exposure",
            "kind" : "path-problem",
            "name" : "Information exposure through a stack trace",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "5.4"
          }
        }, {
          "id" : "go/insecure-randomness",
          "name" : "go/insecure-randomness",
          "shortDescription" : {
            "text" : "Use of insufficient randomness as the key of a cryptographic algorithm"
          },
          "fullDescription" : {
            "text" : "Using insufficient randomness as the key of a cryptographic algorithm can allow an attacker to compromise security."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# Use of insufficient randomness as the key of a cryptographic algorithm\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security sensitive context. As a rule of thumb, a value should be considered \"security sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor Go, `crypto/rand` provides a cryptographically secure pseudo-random number generator. `math/rand` is not cryptographically secure, and should be avoided in security contexts. For contexts which are not security sensitive, `math/rand` may be preferable as it has a more convenient interface, and is likely to be faster.\n\n\n## Example\nThe example below uses the `math/rand` package instead of `crypto/rand` to generate a password:\n\n\n```go\npackage main\n\nimport (\n\t\"math/rand\"\n)\n\nvar charset = []rune(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\n\nfunc generatePassword() string {\n\ts := make([]rune, 20)\n\tfor i := range s {\n\t\ts[i] = charset[rand.Intn(len(charset))]\n\t}\n\treturn string(s)\n}\n\n```\nInstead, use `crypto/rand`:\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"math/big\"\n)\n\nfunc generatePasswordGood() string {\n\ts := make([]rune, 20)\n\tfor i := range s {\n\t\tidx, err := rand.Int(rand.Reader, big.NewInt(int64(len(charset))))\n\t\tif err != nil {\n\t\t\t// handle err\n\t\t}\n\t\ts[i] = charset[idx.Int64()]\n\t}\n\treturn string(s)\n}\n\n```\n\n## References\n* Wikipedia. [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* OWASP: [Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness).\n* OWASP: [Secure Random Number Generation](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation).\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "markdown" : "# Use of insufficient randomness as the key of a cryptographic algorithm\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security sensitive context. As a rule of thumb, a value should be considered \"security sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor Go, `crypto/rand` provides a cryptographically secure pseudo-random number generator. `math/rand` is not cryptographically secure, and should be avoided in security contexts. For contexts which are not security sensitive, `math/rand` may be preferable as it has a more convenient interface, and is likely to be faster.\n\n\n## Example\nThe example below uses the `math/rand` package instead of `crypto/rand` to generate a password:\n\n\n```go\npackage main\n\nimport (\n\t\"math/rand\"\n)\n\nvar charset = []rune(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\n\nfunc generatePassword() string {\n\ts := make([]rune, 20)\n\tfor i := range s {\n\t\ts[i] = charset[rand.Intn(len(charset))]\n\t}\n\treturn string(s)\n}\n\n```\nInstead, use `crypto/rand`:\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"math/big\"\n)\n\nfunc generatePasswordGood() string {\n\ts := make([]rune, 20)\n\tfor i := range s {\n\t\tidx, err := rand.Int(rand.Reader, big.NewInt(int64(len(charset))))\n\t\tif err != nil {\n\t\t\t// handle err\n\t\t}\n\t\ts[i] = charset[idx.Int64()]\n\t}\n\treturn string(s)\n}\n\n```\n\n## References\n* Wikipedia. [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* OWASP: [Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness).\n* OWASP: [Secure Random Number Generation](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation).\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-338" ],
            "description" : "Using insufficient randomness as the key of a cryptographic algorithm can allow an attacker to compromise security.",
            "id" : "go/insecure-randomness",
            "kind" : "path-problem",
            "name" : "Use of insufficient randomness as the key of a cryptographic algorithm",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "7.8"
          }
        }, {
          "id" : "go/path-injection",
          "name" : "go/path-injection",
          "shortDescription" : {
            "text" : "Uncontrolled data used in path expression"
          },
          "fullDescription" : {
            "text" : "Accessing paths influenced by users can allow an attacker to access unexpected resources."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\n\n## Recommendation\nValidate user input before using it to construct a file path, either using an off-the-shelf library or by performing custom validation.\n\nIdeally, follow these rules:\n\n* Do not allow more than a single \".\" character.\n* Do not allow directory separators such as \"/\" or \"\\\\\" (depending on the file system).\n* Do not rely on simply replacing problematic sequences such as \"../\". For example, after applying this filter to \".../...//\", the resulting string would still be \"../\".\n* Use an allowlist of known good patterns.\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
            "markdown" : "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\n\n## Recommendation\nValidate user input before using it to construct a file path, either using an off-the-shelf library or by performing custom validation.\n\nIdeally, follow these rules:\n\n* Do not allow more than a single \".\" character.\n* Do not allow directory separators such as \"/\" or \"\\\\\" (depending on the file system).\n* Do not rely on simply replacing problematic sequences such as \"../\". For example, after applying this filter to \".../...//\", the resulting string would still be \"../\".\n* Use an allowlist of known good patterns.\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-022", "external/cwe/cwe-023", "external/cwe/cwe-036", "external/cwe/cwe-073", "external/cwe/cwe-099" ],
            "description" : "Accessing paths influenced by users can allow an attacker to access\n              unexpected resources.",
            "id" : "go/path-injection",
            "kind" : "path-problem",
            "name" : "Uncontrolled data used in path expression",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "7.5"
          }
        }, {
          "id" : "go/zipslip",
          "name" : "go/zipslip",
          "shortDescription" : {
            "text" : "Arbitrary file access during archive extraction (\"Zip Slip\")"
          },
          "fullDescription" : {
            "text" : "Extracting files from a malicious ZIP file, or similar type of archive, without validating that the destination file path is within the destination directory can allow an attacker to unexpectedly gain access to resources."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# Arbitrary file access during archive extraction (\"Zip Slip\")\nExtracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated. archive paths.\n\nZip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a zip file contains a file entry `..\\sneaky-file`, and the zip file is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a zip archive entry is to check that \"`..`\" does not occur in the path.\n\n\n## Example\nIn this example an archive is extracted without validating file paths. If `archive.zip` contained relative paths (for instance, if it were created by something like `zip archive.zip ../file.txt`) then executing this code could write to locations outside the destination directory.\n\n\n```go\npackage main\n\nimport (\n\t\"archive/zip\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n)\n\nfunc unzip(f string) {\n\tr, _ := zip.OpenReader(f)\n\tfor _, f := range r.File {\n\t\tp, _ := filepath.Abs(f.Name)\n\t\t// BAD: This could overwrite any file on the file system\n\t\tioutil.WriteFile(p, []byte(\"present\"), 0666)\n\t}\n}\n\n```\nTo fix this vulnerability, we need to check that the path does not contain any \"`..`\" elements in it.\n\n\n```go\npackage main\n\nimport (\n\t\"archive/zip\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc unzipGood(f string) {\n\tr, _ := zip.OpenReader(f)\n\tfor _, f := range r.File {\n\t\tp, _ := filepath.Abs(f.Name)\n\t\t// GOOD: Check that path does not contain \"..\" before using it\n\t\tif !strings.Contains(f.Name, \"..\") {\n\t\t\tioutil.WriteFile(p, []byte(\"present\"), 0666)\n\t\t}\n\t}\n}\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n",
            "markdown" : "# Arbitrary file access during archive extraction (\"Zip Slip\")\nExtracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated. archive paths.\n\nZip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a zip file contains a file entry `..\\sneaky-file`, and the zip file is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a zip archive entry is to check that \"`..`\" does not occur in the path.\n\n\n## Example\nIn this example an archive is extracted without validating file paths. If `archive.zip` contained relative paths (for instance, if it were created by something like `zip archive.zip ../file.txt`) then executing this code could write to locations outside the destination directory.\n\n\n```go\npackage main\n\nimport (\n\t\"archive/zip\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n)\n\nfunc unzip(f string) {\n\tr, _ := zip.OpenReader(f)\n\tfor _, f := range r.File {\n\t\tp, _ := filepath.Abs(f.Name)\n\t\t// BAD: This could overwrite any file on the file system\n\t\tioutil.WriteFile(p, []byte(\"present\"), 0666)\n\t}\n}\n\n```\nTo fix this vulnerability, we need to check that the path does not contain any \"`..`\" elements in it.\n\n\n```go\npackage main\n\nimport (\n\t\"archive/zip\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc unzipGood(f string) {\n\tr, _ := zip.OpenReader(f)\n\tfor _, f := range r.File {\n\t\tp, _ := filepath.Abs(f.Name)\n\t\t// GOOD: Check that path does not contain \"..\" before using it\n\t\tif !strings.Contains(f.Name, \"..\") {\n\t\t\tioutil.WriteFile(p, []byte(\"present\"), 0666)\n\t\t}\n\t}\n}\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-022" ],
            "description" : "Extracting files from a malicious ZIP file, or similar type of archive, without\n              validating that the destination file path is within the destination directory\n              can allow an attacker to unexpectedly gain access to resources.",
            "id" : "go/zipslip",
            "kind" : "path-problem",
            "name" : "Arbitrary file access during archive extraction (\"Zip Slip\")",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "7.5"
          }
        }, {
          "id" : "go/unsafe-unzip-symlink",
          "name" : "go/unsafe-unzip-symlink",
          "shortDescription" : {
            "text" : "Arbitrary file write extracting an archive containing symbolic links"
          },
          "fullDescription" : {
            "text" : "Extracting files from a malicious zip archive without validating that the destination file path is within the destination directory can cause files outside the destination directory to be overwritten. Extracting symbolic links in particular requires resolving previously extracted links to ensure the destination directory is not escaped."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# Arbitrary file write extracting an archive containing symbolic links\nExtracting symbolic links from a malicious zip archive, without validating that the destination file path is within the destination directory, can cause files outside the destination directory to be overwritten. This can happen if there are previously-extracted symbolic links or directory traversal elements and links (`..`) in archive paths.\n\nThis problem is related to the ZipSlip vulnerability which is detected by the `go/zipslip` query; please see that query's help for more general information about malicious archive file vulnerabilities. This query considers the specific case where symbolic links are extracted from an archive, in which case the extraction code must be aware of existing symbolic links when checking whether it is about to extract a link pointing to a location outside the target extraction directory.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated. This includes resolving any previously extracted symbolic links, for example using `path/filepath.EvalSymlinks`, to prevent writing files or links to unexpected locations.\n\n\n## Example\nIn this example, links are extracted from an archive using the syntactic `filepath.Rel` function to check whether the link and its target fall within the destination directory. However, the extraction code doesn't resolve previously-extracted links, so a pair of links like `subdir/parent -> ..` followed by `escape -> subdir/parent/.. -> subdir/../..` leaves a link pointing to the parent of the archive root. The syntactic `Rel` is ineffective because it equates `subdir/parent/..` with `subdir/`, but this is not the case when `subdir/parent` is a symbolic link.\n\n\n```go\npackage main\n\nimport (\n\t\"archive/tar\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc isRel(candidate, target string) bool {\n\t// BAD: purely syntactic means are used to check\n\t// that `candidate` does not escape from `target`\n\tif filepath.IsAbs(candidate) {\n\t\treturn false\n\t}\n\trelpath, err := filepath.Rel(target, filepath.Join(target, candidate))\n\treturn err == nil && !strings.HasPrefix(filepath.Clean(relpath), \"..\")\n}\n\nfunc unzipSymlink(f io.Reader, target string) {\n\tr := tar.NewReader(f)\n\tfor {\n\t\theader, err := r.Next()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tif isRel(header.Linkname, target) && isRel(header.Name, target) {\n\t\t\tos.Symlink(header.Linkname, header.Name)\n\t\t}\n\t}\n}\n\n```\nTo fix this vulnerability, resolve pre-existing symbolic links before checking that the link's target is acceptable:\n\n\n```go\npackage main\n\nfunc isRel(candidate, target string) bool {\n\t// GOOD: resolves all symbolic links before checking\n\t// that `candidate` does not escape from `target`\n\tif filepath.IsAbs(candidate) {\n\t\treturn false\n\t}\n\trealpath, err := filepath.EvalSymlinks(filepath.Join(target, candidate))\n\tif err != nil {\n\t\treturn false\n\t}\n\trelpath, err := filepath.Rel(target, realpath)\n\treturn err == nil && !strings.HasPrefix(filepath.Clean(relpath), \"..\")\n}\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n",
            "markdown" : "# Arbitrary file write extracting an archive containing symbolic links\nExtracting symbolic links from a malicious zip archive, without validating that the destination file path is within the destination directory, can cause files outside the destination directory to be overwritten. This can happen if there are previously-extracted symbolic links or directory traversal elements and links (`..`) in archive paths.\n\nThis problem is related to the ZipSlip vulnerability which is detected by the `go/zipslip` query; please see that query's help for more general information about malicious archive file vulnerabilities. This query considers the specific case where symbolic links are extracted from an archive, in which case the extraction code must be aware of existing symbolic links when checking whether it is about to extract a link pointing to a location outside the target extraction directory.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated. This includes resolving any previously extracted symbolic links, for example using `path/filepath.EvalSymlinks`, to prevent writing files or links to unexpected locations.\n\n\n## Example\nIn this example, links are extracted from an archive using the syntactic `filepath.Rel` function to check whether the link and its target fall within the destination directory. However, the extraction code doesn't resolve previously-extracted links, so a pair of links like `subdir/parent -> ..` followed by `escape -> subdir/parent/.. -> subdir/../..` leaves a link pointing to the parent of the archive root. The syntactic `Rel` is ineffective because it equates `subdir/parent/..` with `subdir/`, but this is not the case when `subdir/parent` is a symbolic link.\n\n\n```go\npackage main\n\nimport (\n\t\"archive/tar\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc isRel(candidate, target string) bool {\n\t// BAD: purely syntactic means are used to check\n\t// that `candidate` does not escape from `target`\n\tif filepath.IsAbs(candidate) {\n\t\treturn false\n\t}\n\trelpath, err := filepath.Rel(target, filepath.Join(target, candidate))\n\treturn err == nil && !strings.HasPrefix(filepath.Clean(relpath), \"..\")\n}\n\nfunc unzipSymlink(f io.Reader, target string) {\n\tr := tar.NewReader(f)\n\tfor {\n\t\theader, err := r.Next()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tif isRel(header.Linkname, target) && isRel(header.Name, target) {\n\t\t\tos.Symlink(header.Linkname, header.Name)\n\t\t}\n\t}\n}\n\n```\nTo fix this vulnerability, resolve pre-existing symbolic links before checking that the link's target is acceptable:\n\n\n```go\npackage main\n\nfunc isRel(candidate, target string) bool {\n\t// GOOD: resolves all symbolic links before checking\n\t// that `candidate` does not escape from `target`\n\tif filepath.IsAbs(candidate) {\n\t\treturn false\n\t}\n\trealpath, err := filepath.EvalSymlinks(filepath.Join(target, candidate))\n\tif err != nil {\n\t\treturn false\n\t}\n\trelpath, err := filepath.Rel(target, realpath)\n\treturn err == nil && !strings.HasPrefix(filepath.Clean(relpath), \"..\")\n}\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-022" ],
            "description" : "Extracting files from a malicious zip archive without validating that the\n              destination file path is within the destination directory can cause files outside\n              the destination directory to be overwritten. Extracting symbolic links in particular\n              requires resolving previously extracted links to ensure the destination directory\n              is not escaped.",
            "id" : "go/unsafe-unzip-symlink",
            "kind" : "path-problem",
            "name" : "Arbitrary file write extracting an archive containing symbolic links",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "7.5"
          }
        }, {
          "id" : "go/insecure-hostkeycallback",
          "name" : "go/insecure-hostkeycallback",
          "shortDescription" : {
            "text" : "Use of insecure HostKeyCallback implementation"
          },
          "fullDescription" : {
            "text" : "Detects insecure SSL client configurations with an implementation of the `HostKeyCallback` that accepts all host keys."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "warning"
          },
          "help" : {
            "text" : "# Use of insecure HostKeyCallback implementation\nThe `ClientConfig` specifying the configuration for establishing a SSH connection has a field `HostKeyCallback` that must be initialized with a function that validates the host key returned by the server.\n\nNot properly verifying the host key returned by a server provides attackers with an opportunity to perform a Machine-in-the-Middle (MitM) attack. A successful attack can compromise the confidentiality and integrity of the information communicated with the server.\n\nThe `ssh` package provides the predefined callback `InsecureIgnoreHostKey` that can be used during development and testing. It accepts any provided host key. This callback, or a semantically similar callback, should not be used in production code.\n\n\n## Recommendation\nThe `HostKeyCallback` field of `ClientConfig` should be initialized with a function that validates a host key against an allow list. If a key is not on a predefined allow list, the connection must be terminated and the failed security operation should be logged.\n\nWhen the allow list contains only a single host key then the function `FixedHostKey` can be used.\n\n\n## Example\nThe following example shows the use of `InsecureIgnoreHostKey` and an insecure host key callback implementation commonly used in non-production code.\n\n\n```go\npackage main\n\nimport (\n\t\"golang.org/x/crypto/ssh\"\n\t\"net\"\n)\n\nfunc main() {}\n\nfunc insecureIgnoreHostKey() {\n\t_ = &ssh.ClientConfig{\n\t\tUser:            \"username\",\n\t\tAuth:            []ssh.AuthMethod{nil},\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t}\n}\n\nfunc insecureHostKeyCallback() {\n\t_ = &ssh.ClientConfig{\n\t\tUser: \"username\",\n\t\tAuth: []ssh.AuthMethod{nil},\n\t\tHostKeyCallback: ssh.HostKeyCallback(\n\t\t\tfunc(hostname string, remote net.Addr, key ssh.PublicKey) error {\n\t\t\t\treturn nil\n\t\t\t}),\n\t}\n}\n\n```\nThe next example shows a secure implementation using the `FixedHostKey` that implements an allow-list.\n\n\n```go\npackage main\n\nimport (\n\t\"golang.org/x/crypto/ssh\"\n\t\"io/ioutil\"\n)\n\nfunc main() {}\n\nfunc secureHostKeyCallback() {\n\tpublicKeyBytes, _ := ioutil.ReadFile(\"allowed_hostkey.pub\")\n\tpublicKey, _ := ssh.ParsePublicKey(publicKeyBytes)\n\n\t_ = &ssh.ClientConfig{\n\t\tUser:            \"username\",\n\t\tAuth:            []ssh.AuthMethod{nil},\n\t\tHostKeyCallback: ssh.FixedHostKey(publicKey),\n\t}\n}\n\n```\n\n## References\n* Go Dev: [package ssh](https://pkg.go.dev/golang.org/x/crypto/ssh?tab=doc).\n* Common Weakness Enumeration: [CWE-322](https://cwe.mitre.org/data/definitions/322.html).\n",
            "markdown" : "# Use of insecure HostKeyCallback implementation\nThe `ClientConfig` specifying the configuration for establishing a SSH connection has a field `HostKeyCallback` that must be initialized with a function that validates the host key returned by the server.\n\nNot properly verifying the host key returned by a server provides attackers with an opportunity to perform a Machine-in-the-Middle (MitM) attack. A successful attack can compromise the confidentiality and integrity of the information communicated with the server.\n\nThe `ssh` package provides the predefined callback `InsecureIgnoreHostKey` that can be used during development and testing. It accepts any provided host key. This callback, or a semantically similar callback, should not be used in production code.\n\n\n## Recommendation\nThe `HostKeyCallback` field of `ClientConfig` should be initialized with a function that validates a host key against an allow list. If a key is not on a predefined allow list, the connection must be terminated and the failed security operation should be logged.\n\nWhen the allow list contains only a single host key then the function `FixedHostKey` can be used.\n\n\n## Example\nThe following example shows the use of `InsecureIgnoreHostKey` and an insecure host key callback implementation commonly used in non-production code.\n\n\n```go\npackage main\n\nimport (\n\t\"golang.org/x/crypto/ssh\"\n\t\"net\"\n)\n\nfunc main() {}\n\nfunc insecureIgnoreHostKey() {\n\t_ = &ssh.ClientConfig{\n\t\tUser:            \"username\",\n\t\tAuth:            []ssh.AuthMethod{nil},\n\t\tHostKeyCallback: ssh.InsecureIgnoreHostKey(),\n\t}\n}\n\nfunc insecureHostKeyCallback() {\n\t_ = &ssh.ClientConfig{\n\t\tUser: \"username\",\n\t\tAuth: []ssh.AuthMethod{nil},\n\t\tHostKeyCallback: ssh.HostKeyCallback(\n\t\t\tfunc(hostname string, remote net.Addr, key ssh.PublicKey) error {\n\t\t\t\treturn nil\n\t\t\t}),\n\t}\n}\n\n```\nThe next example shows a secure implementation using the `FixedHostKey` that implements an allow-list.\n\n\n```go\npackage main\n\nimport (\n\t\"golang.org/x/crypto/ssh\"\n\t\"io/ioutil\"\n)\n\nfunc main() {}\n\nfunc secureHostKeyCallback() {\n\tpublicKeyBytes, _ := ioutil.ReadFile(\"allowed_hostkey.pub\")\n\tpublicKey, _ := ssh.ParsePublicKey(publicKeyBytes)\n\n\t_ = &ssh.ClientConfig{\n\t\tUser:            \"username\",\n\t\tAuth:            []ssh.AuthMethod{nil},\n\t\tHostKeyCallback: ssh.FixedHostKey(publicKey),\n\t}\n}\n\n```\n\n## References\n* Go Dev: [package ssh](https://pkg.go.dev/golang.org/x/crypto/ssh?tab=doc).\n* Common Weakness Enumeration: [CWE-322](https://cwe.mitre.org/data/definitions/322.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-322" ],
            "description" : "Detects insecure SSL client configurations with an implementation of the `HostKeyCallback` that accepts all host keys.",
            "id" : "go/insecure-hostkeycallback",
            "kind" : "path-problem",
            "name" : "Use of insecure HostKeyCallback implementation",
            "precision" : "high",
            "problem.severity" : "warning",
            "security-severity" : "8.2"
          }
        }, {
          "id" : "go/allocation-size-overflow",
          "name" : "go/allocation-size-overflow",
          "shortDescription" : {
            "text" : "Size computation for allocation may overflow"
          },
          "fullDescription" : {
            "text" : "When computing the size of an allocation based on the size of a large object, the result may overflow and cause a runtime panic."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "warning"
          },
          "help" : {
            "text" : "# Size computation for allocation may overflow\nPerforming calculations involving the size of potentially large strings or slices can result in an overflow (for signed integer types) or a wraparound (for unsigned types). An overflow causes the result of the calculation to become negative, while a wraparound results in a small (positive) number.\n\nThis can cause further issues. If, for example, the result is then used in an allocation, it will cause a runtime panic if it is negative, and allocate an unexpectedly small buffer otherwise.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations involving potentially large numbers by doing one of the following:\n\n* Validate the size of the data from which the numbers are computed.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type.\n* Use a wider type (such as `uint64` instead of `int`), so that larger input values do not cause overflow.\n\n## Example\nIn the following example, assume that there is a function `encryptBuffer` that encrypts byte slices whose length must be padded to be a multiple of 16. The function `encryptValue` provides a convenience wrapper around this function: when passed an arbitrary value, it first encodes that value as JSON, pads the resulting byte slice, and then passes it to `encryptBuffer`.\n\n\n```go\npackage main\n\nimport \"encoding/json\"\n\nfunc encryptValue(v interface{}) ([]byte, error) {\n\tjsonData, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsize := len(jsonData) + (len(jsonData) % 16)\n\tbuffer := make([]byte, size)\n\tcopy(buffer, jsonData)\n\treturn encryptBuffer(buffer)\n}\n\n```\nWhen passed a value whose JSON encoding is close to the maximum value of type `int` in length, the computation of `size` will overflow, producing a negative value. When that negative value is passed to `make`, a runtime panic will occur.\n\nTo guard against this, the function should be improved to check the length of the JSON-encoded value. For example, here is a version of `encryptValue` that ensures the value is no larger than 64 MB, which fits comfortably within an `int` and avoids the overflow:\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n)\n\nfunc encryptValueGood(v interface{}) ([]byte, error) {\n\tjsonData, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(jsonData) > 64*1024*1024 {\n\t\treturn nil, errors.New(\"value too large\")\n\t}\n\tsize := len(jsonData) + (len(jsonData) % 16)\n\tbuffer := make([]byte, size)\n\tcopy(buffer, jsonData)\n\treturn encryptBuffer(buffer)\n}\n\n```\n\n## References\n* The Go Programming Language Specification: [Integer overflow](https://golang.org/ref/spec#Integer_overflow).\n* The Go Programming Language Specification: [Making slices, maps and channels](https://golang.org/ref/spec#Making_slices_maps_and_channels).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n",
            "markdown" : "# Size computation for allocation may overflow\nPerforming calculations involving the size of potentially large strings or slices can result in an overflow (for signed integer types) or a wraparound (for unsigned types). An overflow causes the result of the calculation to become negative, while a wraparound results in a small (positive) number.\n\nThis can cause further issues. If, for example, the result is then used in an allocation, it will cause a runtime panic if it is negative, and allocate an unexpectedly small buffer otherwise.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations involving potentially large numbers by doing one of the following:\n\n* Validate the size of the data from which the numbers are computed.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type.\n* Use a wider type (such as `uint64` instead of `int`), so that larger input values do not cause overflow.\n\n## Example\nIn the following example, assume that there is a function `encryptBuffer` that encrypts byte slices whose length must be padded to be a multiple of 16. The function `encryptValue` provides a convenience wrapper around this function: when passed an arbitrary value, it first encodes that value as JSON, pads the resulting byte slice, and then passes it to `encryptBuffer`.\n\n\n```go\npackage main\n\nimport \"encoding/json\"\n\nfunc encryptValue(v interface{}) ([]byte, error) {\n\tjsonData, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsize := len(jsonData) + (len(jsonData) % 16)\n\tbuffer := make([]byte, size)\n\tcopy(buffer, jsonData)\n\treturn encryptBuffer(buffer)\n}\n\n```\nWhen passed a value whose JSON encoding is close to the maximum value of type `int` in length, the computation of `size` will overflow, producing a negative value. When that negative value is passed to `make`, a runtime panic will occur.\n\nTo guard against this, the function should be improved to check the length of the JSON-encoded value. For example, here is a version of `encryptValue` that ensures the value is no larger than 64 MB, which fits comfortably within an `int` and avoids the overflow:\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n)\n\nfunc encryptValueGood(v interface{}) ([]byte, error) {\n\tjsonData, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(jsonData) > 64*1024*1024 {\n\t\treturn nil, errors.New(\"value too large\")\n\t}\n\tsize := len(jsonData) + (len(jsonData) % 16)\n\tbuffer := make([]byte, size)\n\tcopy(buffer, jsonData)\n\treturn encryptBuffer(buffer)\n}\n\n```\n\n## References\n* The Go Programming Language Specification: [Integer overflow](https://golang.org/ref/spec#Integer_overflow).\n* The Go Programming Language Specification: [Making slices, maps and channels](https://golang.org/ref/spec#Making_slices_maps_and_channels).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-190" ],
            "description" : "When computing the size of an allocation based on the size of a large object,\n              the result may overflow and cause a runtime panic.",
            "id" : "go/allocation-size-overflow",
            "kind" : "path-problem",
            "name" : "Size computation for allocation may overflow",
            "precision" : "high",
            "problem.severity" : "warning",
            "security-severity" : "8.1"
          }
        }, {
          "id" : "go/command-injection",
          "name" : "go/command-injection",
          "shortDescription" : {
            "text" : "Command built from user-controlled sources"
          },
          "fullDescription" : {
            "text" : "Building a system command from user-controlled sources is vulnerable to insertion of malicious code by the user."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# Command built from user-controlled sources\nIf a system command invocation is built from user-provided data without sufficient sanitization, a malicious user may be able to run commands to exfiltrate data or compromise the system.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run. Instead of interpreting user input directly as command names, examine the input and then choose among hard-coded string literals.\n\nIf this is not possible, then add sanitization code to verify that the user input is safe before using it.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object:\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"os/exec\"\n)\n\nfunc handler(req *http.Request) {\n\tcmdName := req.URL.Query()[\"cmd\"][0]\n\tcmd := exec.Command(cmdName)\n\tcmd.Run()\n}\n\n```\nThe handler extracts the name of a system command from the request object, and then runs it without any further checks, which can cause a command-injection vulnerability.\n\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n",
            "markdown" : "# Command built from user-controlled sources\nIf a system command invocation is built from user-provided data without sufficient sanitization, a malicious user may be able to run commands to exfiltrate data or compromise the system.\n\n\n## Recommendation\nIf possible, use hard-coded string literals to specify the command to run. Instead of interpreting user input directly as command names, examine the input and then choose among hard-coded string literals.\n\nIf this is not possible, then add sanitization code to verify that the user input is safe before using it.\n\n\n## Example\nIn the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object:\n\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"os/exec\"\n)\n\nfunc handler(req *http.Request) {\n\tcmdName := req.URL.Query()[\"cmd\"][0]\n\tcmd := exec.Command(cmdName)\n\tcmd.Run()\n}\n\n```\nThe handler extracts the name of a system command from the request object, and then runs it without any further checks, which can cause a command-injection vulnerability.\n\n\n## References\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-078" ],
            "description" : "Building a system command from user-controlled sources is vulnerable to insertion of\n              malicious code by the user.",
            "id" : "go/command-injection",
            "kind" : "path-problem",
            "name" : "Command built from user-controlled sources",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "9.8"
          }
        }, {
          "id" : "go/weak-crypto-key",
          "name" : "go/weak-crypto-key",
          "shortDescription" : {
            "text" : "Use of a weak cryptographic key"
          },
          "fullDescription" : {
            "text" : "Using a weak cryptographic key can allow an attacker to compromise security."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "error"
          },
          "help" : {
            "text" : "# Use of a weak cryptographic key\nIncorrect uses of encryption algorithms may result in sensitive data exposure, key leakage, broken authentication, insecure session, and spoofing attacks.\n\n\n## Recommendation\nEnsure that you use a strong key with a recommended bit size. For RSA encryption the minimum size is 2048 bits.\n\n\n## Example\nThe following code uses RSA encryption with insufficient key size.\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t//Generate Private Key\n\tpvk, err := rsa.GenerateKey(rand.Reader, 1024)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(pvk)\n}\n\n```\nIn the example below, the key size is set to 2048 bits.\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t//Generate Private Key\n\tpvk, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(pvk)\n}\n\n```\n\n## References\n* OWASP: [Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html).\n* Wikipedia: [Cryptographically Strong Algorithms](https://en.wikipedia.org/wiki/Strong_cryptography#Cryptographically_strong_algorithms).\n* Wikipedia: [Strong Cryptography Examples](https://en.wikipedia.org/wiki/Strong_cryptography#Examples).\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
            "markdown" : "# Use of a weak cryptographic key\nIncorrect uses of encryption algorithms may result in sensitive data exposure, key leakage, broken authentication, insecure session, and spoofing attacks.\n\n\n## Recommendation\nEnsure that you use a strong key with a recommended bit size. For RSA encryption the minimum size is 2048 bits.\n\n\n## Example\nThe following code uses RSA encryption with insufficient key size.\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t//Generate Private Key\n\tpvk, err := rsa.GenerateKey(rand.Reader, 1024)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(pvk)\n}\n\n```\nIn the example below, the key size is set to 2048 bits.\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"fmt\"\n)\n\nfunc main() {\n\t//Generate Private Key\n\tpvk, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(pvk)\n}\n\n```\n\n## References\n* OWASP: [Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html).\n* Wikipedia: [Cryptographically Strong Algorithms](https://en.wikipedia.org/wiki/Strong_cryptography#Cryptographically_strong_algorithms).\n* Wikipedia: [Strong Cryptography Examples](https://en.wikipedia.org/wiki/Strong_cryptography#Examples).\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-326" ],
            "description" : "Using a weak cryptographic key can allow an attacker to compromise security.",
            "id" : "go/weak-crypto-key",
            "kind" : "path-problem",
            "name" : "Use of a weak cryptographic key",
            "precision" : "high",
            "problem.severity" : "error",
            "security-severity" : "7.5"
          }
        }, {
          "id" : "go/insecure-tls",
          "name" : "go/insecure-tls",
          "shortDescription" : {
            "text" : "Insecure TLS configuration"
          },
          "fullDescription" : {
            "text" : "If an application supports insecure TLS versions or ciphers, it may be vulnerable to machine-in-the-middle and other attacks."
          },
          "defaultConfiguration" : {
            "enabled" : true,
            "level" : "warning"
          },
          "help" : {
            "text" : "# Insecure TLS configuration\nThe TLS (Transport Layer Security) protocol secures communications over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.\n\nThe current latest version is 1.3 (with the 1.2 version still being considered secure). Older versions are not deemed to be secure anymore because of various security vulnerabilities, and tht makes them unfit for use in securing your applications.\n\nUnfortunately, many applications and websites still support deprecated SSL/TLS versions and cipher suites.\n\n\n## Recommendation\nOnly use secure TLS versions (1.3 and 1.2) and avoid using insecure cipher suites (you can see a list here: https://golang.org/src/crypto/tls/cipher_suites.go\\#L81)\n\n\n## Example\nThe following example shows a few ways how an insecure TLS configuration can be created:\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n)\n\nfunc main() {}\n\nfunc insecureMinMaxTlsVersion() {\n\t{\n\t\tconfig := &tls.Config{}\n\t\tconfig.MinVersion = 0 // BAD: Setting the MinVersion to 0 equals to choosing the lowest supported version (i.e. SSL3.0)\n\t}\n\t{\n\t\tconfig := &tls.Config{}\n\t\tconfig.MinVersion = tls.VersionSSL30 // BAD: SSL 3.0 is a non-secure version of the protocol; it's not safe to use it as MinVersion.\n\t}\n\t{\n\t\tconfig := &tls.Config{}\n\t\tconfig.MaxVersion = tls.VersionSSL30 // BAD: SSL 3.0 is a non-secure version of the protocol; it's not safe to use it as MaxVersion.\n\t}\n}\n\nfunc insecureCipherSuites() {\n\tconfig := &tls.Config{\n\t\tCipherSuites: []uint16{\n\t\t\ttls.TLS_RSA_WITH_RC4_128_SHA, // BAD: TLS_RSA_WITH_RC4_128_SHA is one of the non-secure cipher suites; it's not safe to be used.\n\t\t},\n\t}\n\t_ = config\n}\n\n```\nThe following example shows how to create a safer TLS configuration:\n\n\n```go\npackage main\n\nimport \"crypto/tls\"\n\nfunc saferTLSConfig() {\n\tconfig := &tls.Config{}\n\tconfig.MinVersion = tls.VersionTLS12\n\tconfig.MaxVersion = tls.VersionTLS13\n\t// OR\n\tconfig.MaxVersion = 0 // GOOD: Setting MaxVersion to 0 means that the highest version available in the package will be used.\n}\n\n```\n\n## References\n* Wikipedia: [Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security)\n* Mozilla: [Security/Server Side TLS](https://wiki.mozilla.org/Security/Server_Side_TLS)\n* OWASP: [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
            "markdown" : "# Insecure TLS configuration\nThe TLS (Transport Layer Security) protocol secures communications over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.\n\nThe current latest version is 1.3 (with the 1.2 version still being considered secure). Older versions are not deemed to be secure anymore because of various security vulnerabilities, and tht makes them unfit for use in securing your applications.\n\nUnfortunately, many applications and websites still support deprecated SSL/TLS versions and cipher suites.\n\n\n## Recommendation\nOnly use secure TLS versions (1.3 and 1.2) and avoid using insecure cipher suites (you can see a list here: https://golang.org/src/crypto/tls/cipher_suites.go\\#L81)\n\n\n## Example\nThe following example shows a few ways how an insecure TLS configuration can be created:\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n)\n\nfunc main() {}\n\nfunc insecureMinMaxTlsVersion() {\n\t{\n\t\tconfig := &tls.Config{}\n\t\tconfig.MinVersion = 0 // BAD: Setting the MinVersion to 0 equals to choosing the lowest supported version (i.e. SSL3.0)\n\t}\n\t{\n\t\tconfig := &tls.Config{}\n\t\tconfig.MinVersion = tls.VersionSSL30 // BAD: SSL 3.0 is a non-secure version of the protocol; it's not safe to use it as MinVersion.\n\t}\n\t{\n\t\tconfig := &tls.Config{}\n\t\tconfig.MaxVersion = tls.VersionSSL30 // BAD: SSL 3.0 is a non-secure version of the protocol; it's not safe to use it as MaxVersion.\n\t}\n}\n\nfunc insecureCipherSuites() {\n\tconfig := &tls.Config{\n\t\tCipherSuites: []uint16{\n\t\t\ttls.TLS_RSA_WITH_RC4_128_SHA, // BAD: TLS_RSA_WITH_RC4_128_SHA is one of the non-secure cipher suites; it's not safe to be used.\n\t\t},\n\t}\n\t_ = config\n}\n\n```\nThe following example shows how to create a safer TLS configuration:\n\n\n```go\npackage main\n\nimport \"crypto/tls\"\n\nfunc saferTLSConfig() {\n\tconfig := &tls.Config{}\n\tconfig.MinVersion = tls.VersionTLS12\n\tconfig.MaxVersion = tls.VersionTLS13\n\t// OR\n\tconfig.MaxVersion = 0 // GOOD: Setting MaxVersion to 0 means that the highest version available in the package will be used.\n}\n\n```\n\n## References\n* Wikipedia: [Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security)\n* Mozilla: [Security/Server Side TLS](https://wiki.mozilla.org/Security/Server_Side_TLS)\n* OWASP: [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"
          },
          "properties" : {
            "tags" : [ "security", "external/cwe/cwe-327" ],
            "description" : "If an application supports insecure TLS versions or ciphers, it may be vulnerable to\n              machine-in-the-middle and other attacks.",
            "id" : "go/insecure-tls",
            "kind" : "path-problem",
            "name" : "Insecure TLS configuration",
            "precision" : "very-high",
            "problem.severity" : "warning",
            "security-severity" : "7.5"
          }
        }, {
          "id" : "go/summary/lines-of-code",
          "name" : "go/summary/lines-of-code",
          "shortDescription" : {
            "text" : "Total lines of Go code in the database"
          },
          "fullDescription" : {
            "text" : "The total number of lines of Go code across all extracted files, including auto-generated files. This is a useful metric of the size of a database. For all files that were seen during the build, this query counts the lines of code, excluding whitespace or comments."
          },
          "defaultConfiguration" : {
            "enabled" : true
          },
          "properties" : {
            "tags" : [ "summary", "lines-of-code" ],
            "description" : "The total number of lines of Go code across all extracted files, including auto-generated files. This is a useful metric of the size of a database. For all files that were seen during the build, this query counts the lines of code, excluding whitespace or comments.",
            "id" : "go/summary/lines-of-code",
            "kind" : "metric",
            "name" : "Total lines of Go code in the database"
          }
        } ],
        "locations" : [ {
          "uri" : "file:///opt/hostedtoolcache/CodeQL/2.15.1/x64/codeql/qlpacks/codeql/go-queries/0.7.1/",
          "description" : {
            "text" : "The QL pack root directory."
          }
        }, {
          "uri" : "file:///opt/hostedtoolcache/CodeQL/2.15.1/x64/codeql/qlpacks/codeql/go-queries/0.7.1/qlpack.yml",
          "description" : {
            "text" : "The QL pack definition file."
          }
        } ]
      } ]
    },
    "invocations" : [ {
      "toolExecutionNotifications" : [ {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/go.mod",
              "uriBaseId" : "%SRCROOT%",
              "index" : 1
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "gallery/go.mod",
              "uriBaseId" : "%SRCROOT%",
              "index" : 2
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "gallery/main.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 0
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/op/login.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 3
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/op/templates.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 4
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/storage/oidc.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 5
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/storage/storage.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 6
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/storage/token.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 7
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/storage/user.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 8
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/op/templates/confirm_device.html",
              "uriBaseId" : "%SRCROOT%",
              "index" : 9
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/op/templates/device_login.html",
              "uriBaseId" : "%SRCROOT%",
              "index" : 10
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/op/templates/login.html",
              "uriBaseId" : "%SRCROOT%",
              "index" : 11
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/op/templates/usercode.html",
              "uriBaseId" : "%SRCROOT%",
              "index" : 12
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/index.html",
              "uriBaseId" : "%SRCROOT%",
              "index" : 13
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/App.vue",
              "uriBaseId" : "%SRCROOT%",
              "index" : 14
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/components/AuthorizationCallback.vue",
              "uriBaseId" : "%SRCROOT%",
              "index" : 15
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/components/Gallery.vue",
              "uriBaseId" : "%SRCROOT%",
              "index" : 16
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/components/Login.vue",
              "uriBaseId" : "%SRCROOT%",
              "index" : 17
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/components/Logout.vue",
              "uriBaseId" : "%SRCROOT%",
              "index" : 18
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/components/NotFound.vue",
              "uriBaseId" : "%SRCROOT%",
              "index" : 19
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/views/AuthorizationCallbackView.vue",
              "uriBaseId" : "%SRCROOT%",
              "index" : 20
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/views/GalleryView.vue",
              "uriBaseId" : "%SRCROOT%",
              "index" : 21
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/views/LoginView.vue",
              "uriBaseId" : "%SRCROOT%",
              "index" : 22
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/views/NotFoundView.vue",
              "uriBaseId" : "%SRCROOT%",
              "index" : 23
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/views/LogoutView.vue",
              "uriBaseId" : "%SRCROOT%",
              "index" : 24
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "root/src/github.com/zitadel/oidc/example/server/exampleop/templates/confirm_device.html",
              "uriBaseId" : "%SRCROOT%",
              "index" : 25
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "root/src/github.com/zitadel/oidc/example/server/exampleop/templates/device_login.html",
              "uriBaseId" : "%SRCROOT%",
              "index" : 26
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "root/src/github.com/zitadel/oidc/example/server/exampleop/templates/login.html",
              "uriBaseId" : "%SRCROOT%",
              "index" : 27
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "root/src/github.com/zitadel/oidc/example/server/exampleop/templates/usercode.html",
              "uriBaseId" : "%SRCROOT%",
              "index" : 28
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "go/diagnostics/successfully-extracted-files",
          "index" : 0,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "message" : {
          "text" : "Extraction failed in auth/main.go with error could not import auth/op (invalid package name: \"\")"
        },
        "level" : "error",
        "descriptor" : {
          "id" : "go/diagnostics/extraction-errors",
          "index" : 1,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : "Extraction failed in auth/main.go with error could not import auth/op (invalid package name: \"\")"
          }
        }
      }, {
        "message" : {
          "text" : "Extraction failed in auth/main.go with error could not import auth/storage (invalid package name: \"\")"
        },
        "level" : "error",
        "descriptor" : {
          "id" : "go/diagnostics/extraction-errors",
          "index" : 1,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : "Extraction failed in auth/main.go with error could not import auth/storage (invalid package name: \"\")"
          }
        }
      }, {
        "message" : {
          "text" : "Extraction failed in auth/op/op.go with error could not import auth/storage (invalid package name: \"\")"
        },
        "level" : "error",
        "descriptor" : {
          "id" : "go/diagnostics/extraction-errors",
          "index" : 1,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : "Extraction failed in auth/op/op.go with error could not import auth/storage (invalid package name: \"\")"
          }
        }
      }, {
        "message" : {
          "text" : "Extraction failed in auth/op/device.go with error could not import github.com/zitadel/oidc/v2/pkg/op (invalid package name: \"\")"
        },
        "level" : "error",
        "descriptor" : {
          "id" : "go/diagnostics/extraction-errors",
          "index" : 1,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : "Extraction failed in auth/op/device.go with error could not import github.com/zitadel/oidc/v2/pkg/op (invalid package name: \"\")"
          }
        }
      }, {
        "message" : {
          "text" : "Extraction failed in auth/storage/client.go with error could not import github.com/zitadel/oidc/v2/pkg/op (invalid package name: \"\")"
        },
        "level" : "error",
        "descriptor" : {
          "id" : "go/diagnostics/extraction-errors",
          "index" : 1,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : "Extraction failed in auth/storage/client.go with error could not import github.com/zitadel/oidc/v2/pkg/op (invalid package name: \"\")"
          }
        }
      }, {
        "message" : {
          "text" : "Extraction failed in auth/op/device.go with error d.storage.GetDeviceAuthorizationByUserCode undefined (type deviceAuthenticate has no field or method GetDeviceAuthorizationByUserCode)"
        },
        "level" : "error",
        "descriptor" : {
          "id" : "go/diagnostics/extraction-errors",
          "index" : 1,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : "Extraction failed in auth/op/device.go with error d.storage.GetDeviceAuthorizationByUserCode undefined (type deviceAuthenticate has no field or method GetDeviceAuthorizationByUserCode)"
          }
        }
      }, {
        "message" : {
          "text" : "Extraction failed in auth/op/device.go with error d.storage.CompleteDeviceAuthorization undefined (type deviceAuthenticate has no field or method CompleteDeviceAuthorization)"
        },
        "level" : "error",
        "descriptor" : {
          "id" : "go/diagnostics/extraction-errors",
          "index" : 1,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : "Extraction failed in auth/op/device.go with error d.storage.CompleteDeviceAuthorization undefined (type deviceAuthenticate has no field or method CompleteDeviceAuthorization)"
          }
        }
      }, {
        "message" : {
          "text" : "Extraction failed in auth/op/device.go with error d.storage.DenyDeviceAuthorization undefined (type deviceAuthenticate has no field or method DenyDeviceAuthorization)"
        },
        "level" : "error",
        "descriptor" : {
          "id" : "go/diagnostics/extraction-errors",
          "index" : 1,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : "Extraction failed in auth/op/device.go with error d.storage.DenyDeviceAuthorization undefined (type deviceAuthenticate has no field or method DenyDeviceAuthorization)"
          }
        }
      }, {
        "message" : {
          "text" : "Extraction failed in auth/storage/client.go with error could not import github.com/zitadel/oidc/v2/pkg/oidc (invalid package name: \"\")"
        },
        "level" : "error",
        "descriptor" : {
          "id" : "go/diagnostics/extraction-errors",
          "index" : 1,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : "Extraction failed in auth/storage/client.go with error could not import github.com/zitadel/oidc/v2/pkg/oidc (invalid package name: \"\")"
          }
        }
      }, {
        "message" : {
          "text" : "Extraction failed in auth/main.go with error cannot find package \"auth/storage\" in any of:\n\t(absolute path) (from $GOROOT)\n\t(absolute path) (from $GOPATH)"
        },
        "level" : "error",
        "descriptor" : {
          "id" : "go/diagnostics/extraction-errors",
          "index" : 1,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : "Extraction failed in auth/main.go with error cannot find package \"auth/storage\" in any of:\n\t(absolute path) (from $GOROOT)\n\t(absolute path) (from $GOPATH)"
          }
        }
      }, {
        "message" : {
          "text" : "Extraction failed in auth/main.go with error cannot find package \"auth/op\" in any of:\n\t(absolute path) (from $GOROOT)\n\t(absolute path) (from $GOPATH)"
        },
        "level" : "error",
        "descriptor" : {
          "id" : "go/diagnostics/extraction-errors",
          "index" : 1,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : "Extraction failed in auth/main.go with error cannot find package \"auth/op\" in any of:\n\t(absolute path) (from $GOROOT)\n\t(absolute path) (from $GOPATH)"
          }
        }
      }, {
        "message" : {
          "text" : "Extraction failed in auth/op/device.go with error cannot find package \"github.com/zitadel/oidc/v2/pkg/op\" in any of:\n\t(absolute path) (from $GOROOT)\n\t(absolute path) (from $GOPATH)"
        },
        "level" : "error",
        "descriptor" : {
          "id" : "go/diagnostics/extraction-errors",
          "index" : 1,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : "Extraction failed in auth/op/device.go with error cannot find package \"github.com/zitadel/oidc/v2/pkg/op\" in any of:\n\t(absolute path) (from $GOROOT)\n\t(absolute path) (from $GOPATH)"
          }
        }
      }, {
        "message" : {
          "text" : "Extraction failed in auth/storage/client.go with error cannot find package \"github.com/zitadel/oidc/v2/pkg/oidc\" in any of:\n\t(absolute path) (from $GOROOT)\n\t(absolute path) (from $GOPATH)"
        },
        "level" : "error",
        "descriptor" : {
          "id" : "go/diagnostics/extraction-errors",
          "index" : 1,
          "toolComponent" : {
            "index" : 0
          }
        },
        "properties" : {
          "formattedMessage" : {
            "text" : "Extraction failed in auth/storage/client.go with error cannot find package \"github.com/zitadel/oidc/v2/pkg/oidc\" in any of:\n\t(absolute path) (from $GOROOT)\n\t(absolute path) (from $GOPATH)"
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/security/JwtAuthenticationException.java",
              "uriBaseId" : "%SRCROOT%",
              "index" : 29
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/java",
          "index" : 0
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/config/MinioConfig.java",
              "uriBaseId" : "%SRCROOT%",
              "index" : 30
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/java",
          "index" : 0
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/security/JwtAuthenticationToken.java",
              "uriBaseId" : "%SRCROOT%",
              "index" : 31
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/java",
          "index" : 0
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/models/Blob.java",
              "uriBaseId" : "%SRCROOT%",
              "index" : 32
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/java",
          "index" : 0
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/security/JwtAuthenticationProvider.java",
              "uriBaseId" : "%SRCROOT%",
              "index" : 33
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/java",
          "index" : 0
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/models/Profile.java",
              "uriBaseId" : "%SRCROOT%",
              "index" : 34
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/java",
          "index" : 0
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/controllers/BlobController.java",
              "uriBaseId" : "%SRCROOT%",
              "index" : 35
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/java",
          "index" : 0
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/security/BearerAuthenticationFilter.java",
              "uriBaseId" : "%SRCROOT%",
              "index" : 36
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/java",
          "index" : 0
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/App.java",
              "uriBaseId" : "%SRCROOT%",
              "index" : 37
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/java",
          "index" : 0
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/security/JwtAuthenticationSuccessHandler.java",
              "uriBaseId" : "%SRCROOT%",
              "index" : 38
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/java",
          "index" : 0
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/security/JwtAccessDeniedHandler.java",
              "uriBaseId" : "%SRCROOT%",
              "index" : 39
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/java",
          "index" : 0
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/WebSecurityConfig.java",
              "uriBaseId" : "%SRCROOT%",
              "index" : 40
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/java",
          "index" : 0
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/security/JwtAuthenticationEntryPoint.java",
              "uriBaseId" : "%SRCROOT%",
              "index" : 41
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/java",
          "index" : 0
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/op/op.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 42
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/go",
          "index" : 1
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/storage/storage.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 6
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/go",
          "index" : 1
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/storage/token.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 7
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/go",
          "index" : 1
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/op/device.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 43
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/go",
          "index" : 1
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/storage/user.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 8
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/go",
          "index" : 1
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/storage/oidc.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 5
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/go",
          "index" : 1
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/op/templates.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 4
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/go",
          "index" : 1
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/op/login.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 3
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/go",
          "index" : 1
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/storage/client.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 44
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/go",
          "index" : 1
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth/main.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 45
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/go",
          "index" : 1
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "gallery/main.go",
              "uriBaseId" : "%SRCROOT%",
              "index" : 0
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/go",
          "index" : 1
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/stores/counter.js",
              "uriBaseId" : "%SRCROOT%",
              "index" : 46
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/javascript",
          "index" : 2
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/main.js",
              "uriBaseId" : "%SRCROOT%",
              "index" : 47
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/javascript",
          "index" : 2
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/vite.config.js",
              "uriBaseId" : "%SRCROOT%",
              "index" : 48
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/javascript",
          "index" : 2
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/stores/store.js",
              "uriBaseId" : "%SRCROOT%",
              "index" : 49
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/javascript",
          "index" : 2
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "frontend/src/router/index.js",
              "uriBaseId" : "%SRCROOT%",
              "index" : 50
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/javascript",
          "index" : 2
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "locations" : [ {
          "physicalLocation" : {
            "artifactLocation" : {
              "uri" : "auth-ext/app.py",
              "uriBaseId" : "%SRCROOT%",
              "index" : 51
            }
          }
        } ],
        "message" : {
          "text" : ""
        },
        "level" : "none",
        "descriptor" : {
          "id" : "cli/expected-extracted-files/python",
          "index" : 3
        },
        "properties" : {
          "formattedMessage" : {
            "text" : ""
          }
        }
      }, {
        "message" : {
          "text" : "2 `go.mod` files were found:\n\n`auth/go.mod`, `gallery/go.mod`",
          "markdown" : "2 `go.mod` files were found:\n\n`auth/go.mod`, `gallery/go.mod`"
        },
        "level" : "note",
        "timeUtc" : "2023-10-26T05:08:51.645+00:00",
        "descriptor" : {
          "id" : "go/autobuilder/multiple-go-mod-found-not-nested",
          "index" : 4
        },
        "properties" : {
          "visibility" : {
            "statusPage" : false,
            "telemetry" : true
          }
        }
      }, {
        "message" : {
          "text" : "4 packages could not be found:\n\n`auth/op`, `auth/storage`, `github.com/zitadel/oidc/v2/pkg/op`, `github.com/zitadel/oidc/v2/pkg/oidc`.\n\nDefinitions in those packages may not be recognized by CodeQL, and files that use them may only be partially analyzed.\n\nCheck that the paths are correct and make sure any private packages can be accessed. If any of the packages are present in the repository then you may need a [custom build command](https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-the-codeql-workflow-for-compiled-languages).",
          "markdown" : "4 packages could not be found:\n\n`auth/op`, `auth/storage`, `github.com/zitadel/oidc/v2/pkg/op`, `github.com/zitadel/oidc/v2/pkg/oidc`.\n\nDefinitions in those packages may not be recognized by CodeQL, and files that use them may only be partially analyzed.\n\nCheck that the paths are correct and make sure any private packages can be accessed. If any of the packages are present in the repository then you may need a [custom build command](https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-the-codeql-workflow-for-compiled-languages)."
        },
        "timeUtc" : "2023-10-26T05:10:13.766+00:00",
        "descriptor" : {
          "id" : "go/autobuilder/package-not-found",
          "index" : 5
        },
        "properties" : {
          "visibility" : {
            "statusPage" : true,
            "telemetry" : true
          }
        }
      } ],
      "executionSuccessful" : true
    } ],
    "artifacts" : [ {
      "location" : {
        "uri" : "gallery/main.go",
        "uriBaseId" : "%SRCROOT%",
        "index" : 0
      }
    }, {
      "location" : {
        "uri" : "auth/go.mod",
        "uriBaseId" : "%SRCROOT%",
        "index" : 1
      }
    }, {
      "location" : {
        "uri" : "gallery/go.mod",
        "uriBaseId" : "%SRCROOT%",
        "index" : 2
      }
    }, {
      "location" : {
        "uri" : "auth/op/login.go",
        "uriBaseId" : "%SRCROOT%",
        "index" : 3
      }
    }, {
      "location" : {
        "uri" : "auth/op/templates.go",
        "uriBaseId" : "%SRCROOT%",
        "index" : 4
      }
    }, {
      "location" : {
        "uri" : "auth/storage/oidc.go",
        "uriBaseId" : "%SRCROOT%",
        "index" : 5
      }
    }, {
      "location" : {
        "uri" : "auth/storage/storage.go",
        "uriBaseId" : "%SRCROOT%",
        "index" : 6
      }
    }, {
      "location" : {
        "uri" : "auth/storage/token.go",
        "uriBaseId" : "%SRCROOT%",
        "index" : 7
      }
    }, {
      "location" : {
        "uri" : "auth/storage/user.go",
        "uriBaseId" : "%SRCROOT%",
        "index" : 8
      }
    }, {
      "location" : {
        "uri" : "auth/op/templates/confirm_device.html",
        "uriBaseId" : "%SRCROOT%",
        "index" : 9
      }
    }, {
      "location" : {
        "uri" : "auth/op/templates/device_login.html",
        "uriBaseId" : "%SRCROOT%",
        "index" : 10
      }
    }, {
      "location" : {
        "uri" : "auth/op/templates/login.html",
        "uriBaseId" : "%SRCROOT%",
        "index" : 11
      }
    }, {
      "location" : {
        "uri" : "auth/op/templates/usercode.html",
        "uriBaseId" : "%SRCROOT%",
        "index" : 12
      }
    }, {
      "location" : {
        "uri" : "frontend/index.html",
        "uriBaseId" : "%SRCROOT%",
        "index" : 13
      }
    }, {
      "location" : {
        "uri" : "frontend/src/App.vue",
        "uriBaseId" : "%SRCROOT%",
        "index" : 14
      }
    }, {
      "location" : {
        "uri" : "frontend/src/components/AuthorizationCallback.vue",
        "uriBaseId" : "%SRCROOT%",
        "index" : 15
      }
    }, {
      "location" : {
        "uri" : "frontend/src/components/Gallery.vue",
        "uriBaseId" : "%SRCROOT%",
        "index" : 16
      }
    }, {
      "location" : {
        "uri" : "frontend/src/components/Login.vue",
        "uriBaseId" : "%SRCROOT%",
        "index" : 17
      }
    }, {
      "location" : {
        "uri" : "frontend/src/components/Logout.vue",
        "uriBaseId" : "%SRCROOT%",
        "index" : 18
      }
    }, {
      "location" : {
        "uri" : "frontend/src/components/NotFound.vue",
        "uriBaseId" : "%SRCROOT%",
        "index" : 19
      }
    }, {
      "location" : {
        "uri" : "frontend/src/views/AuthorizationCallbackView.vue",
        "uriBaseId" : "%SRCROOT%",
        "index" : 20
      }
    }, {
      "location" : {
        "uri" : "frontend/src/views/GalleryView.vue",
        "uriBaseId" : "%SRCROOT%",
        "index" : 21
      }
    }, {
      "location" : {
        "uri" : "frontend/src/views/LoginView.vue",
        "uriBaseId" : "%SRCROOT%",
        "index" : 22
      }
    }, {
      "location" : {
        "uri" : "frontend/src/views/NotFoundView.vue",
        "uriBaseId" : "%SRCROOT%",
        "index" : 23
      }
    }, {
      "location" : {
        "uri" : "frontend/src/views/LogoutView.vue",
        "uriBaseId" : "%SRCROOT%",
        "index" : 24
      }
    }, {
      "location" : {
        "uri" : "root/src/github.com/zitadel/oidc/example/server/exampleop/templates/confirm_device.html",
        "uriBaseId" : "%SRCROOT%",
        "index" : 25
      }
    }, {
      "location" : {
        "uri" : "root/src/github.com/zitadel/oidc/example/server/exampleop/templates/device_login.html",
        "uriBaseId" : "%SRCROOT%",
        "index" : 26
      }
    }, {
      "location" : {
        "uri" : "root/src/github.com/zitadel/oidc/example/server/exampleop/templates/login.html",
        "uriBaseId" : "%SRCROOT%",
        "index" : 27
      }
    }, {
      "location" : {
        "uri" : "root/src/github.com/zitadel/oidc/example/server/exampleop/templates/usercode.html",
        "uriBaseId" : "%SRCROOT%",
        "index" : 28
      }
    }, {
      "location" : {
        "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/security/JwtAuthenticationException.java",
        "uriBaseId" : "%SRCROOT%",
        "index" : 29
      }
    }, {
      "location" : {
        "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/config/MinioConfig.java",
        "uriBaseId" : "%SRCROOT%",
        "index" : 30
      }
    }, {
      "location" : {
        "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/security/JwtAuthenticationToken.java",
        "uriBaseId" : "%SRCROOT%",
        "index" : 31
      }
    }, {
      "location" : {
        "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/models/Blob.java",
        "uriBaseId" : "%SRCROOT%",
        "index" : 32
      }
    }, {
      "location" : {
        "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/security/JwtAuthenticationProvider.java",
        "uriBaseId" : "%SRCROOT%",
        "index" : 33
      }
    }, {
      "location" : {
        "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/models/Profile.java",
        "uriBaseId" : "%SRCROOT%",
        "index" : 34
      }
    }, {
      "location" : {
        "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/controllers/BlobController.java",
        "uriBaseId" : "%SRCROOT%",
        "index" : 35
      }
    }, {
      "location" : {
        "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/security/BearerAuthenticationFilter.java",
        "uriBaseId" : "%SRCROOT%",
        "index" : 36
      }
    }, {
      "location" : {
        "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/App.java",
        "uriBaseId" : "%SRCROOT%",
        "index" : 37
      }
    }, {
      "location" : {
        "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/security/JwtAuthenticationSuccessHandler.java",
        "uriBaseId" : "%SRCROOT%",
        "index" : 38
      }
    }, {
      "location" : {
        "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/security/JwtAccessDeniedHandler.java",
        "uriBaseId" : "%SRCROOT%",
        "index" : 39
      }
    }, {
      "location" : {
        "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/WebSecurityConfig.java",
        "uriBaseId" : "%SRCROOT%",
        "index" : 40
      }
    }, {
      "location" : {
        "uri" : "storage/src/main/java/com/github/advancedsecurity/storageservice/security/JwtAuthenticationEntryPoint.java",
        "uriBaseId" : "%SRCROOT%",
        "index" : 41
      }
    }, {
      "location" : {
        "uri" : "auth/op/op.go",
        "uriBaseId" : "%SRCROOT%",
        "index" : 42
      }
    }, {
      "location" : {
        "uri" : "auth/op/device.go",
        "uriBaseId" : "%SRCROOT%",
        "index" : 43
      }
    }, {
      "location" : {
        "uri" : "auth/storage/client.go",
        "uriBaseId" : "%SRCROOT%",
        "index" : 44
      }
    }, {
      "location" : {
        "uri" : "auth/main.go",
        "uriBaseId" : "%SRCROOT%",
        "index" : 45
      }
    }, {
      "location" : {
        "uri" : "frontend/src/stores/counter.js",
        "uriBaseId" : "%SRCROOT%",
        "index" : 46
      }
    }, {
      "location" : {
        "uri" : "frontend/src/main.js",
        "uriBaseId" : "%SRCROOT%",
        "index" : 47
      }
    }, {
      "location" : {
        "uri" : "frontend/vite.config.js",
        "uriBaseId" : "%SRCROOT%",
        "index" : 48
      }
    }, {
      "location" : {
        "uri" : "frontend/src/stores/store.js",
        "uriBaseId" : "%SRCROOT%",
        "index" : 49
      }
    }, {
      "location" : {
        "uri" : "frontend/src/router/index.js",
        "uriBaseId" : "%SRCROOT%",
        "index" : 50
      }
    }, {
      "location" : {
        "uri" : "auth-ext/app.py",
        "uriBaseId" : "%SRCROOT%",
        "index" : 51
      }
    } ],
    "results" : [ {
      "ruleId" : "go/sql-injection",
      "rule" : {
        "id" : "go/sql-injection",
        "index" : 8,
        "toolComponent" : {
          "index" : 0
        }
      },
      "message" : {
        "text" : "This query depends on a [user-provided value](1).\nThis query depends on a [user-provided value](2).\nThis query depends on a [user-provided value](3)."
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "gallery/main.go",
            "uriBaseId" : "%SRCROOT%",
            "index" : 0
          },
          "region" : {
            "startLine" : 200,
            "startColumn" : 26,
            "endColumn" : 31
          }
        }
      } ],
      "partialFingerprints" : {
        "primaryLocationLineHash" : "3a837e3cc6892848:1",
        "primaryLocationStartColumnFingerprint" : "24"
      },
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 352,
                  "startColumn" : 17,
                  "endColumn" : 25
                }
              },
              "message" : {
                "text" : "selection of Header"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 352,
                  "startColumn" : 17,
                  "endColumn" : 56
                }
              },
              "message" : {
                "text" : "call to Get"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 352,
                  "startColumn" : 2,
                  "endColumn" : 9
                }
              },
              "message" : {
                "text" : "implicit dereference [Name]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 350,
                  "startColumn" : 2,
                  "endColumn" : 9
                }
              },
              "message" : {
                "text" : "definition of profile [pointer, Name]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 356,
                  "startColumn" : 9,
                  "endColumn" : 16
                }
              },
              "message" : {
                "text" : "profile [pointer, Name]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 440,
                  "startColumn" : 13,
                  "endColumn" : 26
                }
              },
              "message" : {
                "text" : "call to GetProfile [pointer, Name]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 451,
                  "startColumn" : 48,
                  "endColumn" : 55
                }
              },
              "message" : {
                "text" : "profile [pointer, Name]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 451,
                  "startColumn" : 48,
                  "endColumn" : 55
                }
              },
              "message" : {
                "text" : "implicit dereference [Name]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 451,
                  "startColumn" : 48,
                  "endColumn" : 60
                }
              },
              "message" : {
                "text" : "selection of Name"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 451,
                  "startColumn" : 19,
                  "endColumn" : 60
                }
              },
              "message" : {
                "text" : "...+..."
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 441,
                  "startColumn" : 6,
                  "endColumn" : 13
                }
              },
              "message" : {
                "text" : "definition of gallery [Title]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 453,
                  "startColumn" : 10,
                  "endColumn" : 17
                }
              },
              "message" : {
                "text" : "gallery [Title]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 196,
                  "startColumn" : 7,
                  "endColumn" : 8
                }
              },
              "message" : {
                "text" : "definition of g [Title]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 198,
                  "startColumn" : 109,
                  "endColumn" : 110
                }
              },
              "message" : {
                "text" : "g [Title]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 198,
                  "startColumn" : 109,
                  "endColumn" : 116
                }
              },
              "message" : {
                "text" : "selection of Title"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 198,
                  "startColumn" : 11,
                  "endColumn" : 153
                }
              },
              "message" : {
                "text" : "call to Sprintf"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 200,
                  "startColumn" : 26,
                  "endColumn" : 31
                }
              },
              "message" : {
                "text" : "query"
              }
            }
          } ]
        } ]
      }, {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 353,
                  "startColumn" : 18,
                  "endColumn" : 26
                }
              },
              "message" : {
                "text" : "selection of Header"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 353,
                  "startColumn" : 18,
                  "endColumn" : 58
                }
              },
              "message" : {
                "text" : "call to Get"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 353,
                  "startColumn" : 2,
                  "endColumn" : 9
                }
              },
              "message" : {
                "text" : "implicit dereference [Email]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 350,
                  "startColumn" : 2,
                  "endColumn" : 9
                }
              },
              "message" : {
                "text" : "definition of profile [pointer, Email]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 354,
                  "startColumn" : 18,
                  "endColumn" : 25
                }
              },
              "message" : {
                "text" : "profile [pointer, Email]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 354,
                  "startColumn" : 18,
                  "endColumn" : 25
                }
              },
              "message" : {
                "text" : "implicit dereference [Email]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 354,
                  "startColumn" : 18,
                  "endColumn" : 31
                }
              },
              "message" : {
                "text" : "selection of Email"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 354,
                  "startColumn" : 2,
                  "endColumn" : 9
                }
              },
              "message" : {
                "text" : "implicit dereference [Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 350,
                  "startColumn" : 2,
                  "endColumn" : 9
                }
              },
              "message" : {
                "text" : "definition of profile [pointer, Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 356,
                  "startColumn" : 9,
                  "endColumn" : 16
                }
              },
              "message" : {
                "text" : "profile [pointer, Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 373,
                  "startColumn" : 13,
                  "endColumn" : 26
                }
              },
              "message" : {
                "text" : "call to GetProfile [pointer, Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 383,
                  "startColumn" : 23,
                  "endColumn" : 30
                }
              },
              "message" : {
                "text" : "profile [pointer, Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 196,
                  "startColumn" : 25,
                  "endColumn" : 32
                }
              },
              "message" : {
                "text" : "definition of profile [pointer, Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 198,
                  "startColumn" : 139,
                  "endColumn" : 146
                }
              },
              "message" : {
                "text" : "profile [pointer, Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 198,
                  "startColumn" : 139,
                  "endColumn" : 146
                }
              },
              "message" : {
                "text" : "implicit dereference [Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 198,
                  "startColumn" : 139,
                  "endColumn" : 152
                }
              },
              "message" : {
                "text" : "selection of Login"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 198,
                  "startColumn" : 11,
                  "endColumn" : 153
                }
              },
              "message" : {
                "text" : "call to Sprintf"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 200,
                  "startColumn" : 26,
                  "endColumn" : 31
                }
              },
              "message" : {
                "text" : "query"
              }
            }
          } ]
        } ]
      }, {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 353,
                  "startColumn" : 18,
                  "endColumn" : 26
                }
              },
              "message" : {
                "text" : "selection of Header"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 353,
                  "startColumn" : 18,
                  "endColumn" : 58
                }
              },
              "message" : {
                "text" : "call to Get"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 353,
                  "startColumn" : 2,
                  "endColumn" : 9
                }
              },
              "message" : {
                "text" : "implicit dereference [Email]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 350,
                  "startColumn" : 2,
                  "endColumn" : 9
                }
              },
              "message" : {
                "text" : "definition of profile [pointer, Email]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 354,
                  "startColumn" : 18,
                  "endColumn" : 25
                }
              },
              "message" : {
                "text" : "profile [pointer, Email]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 354,
                  "startColumn" : 18,
                  "endColumn" : 25
                }
              },
              "message" : {
                "text" : "implicit dereference [Email]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 354,
                  "startColumn" : 18,
                  "endColumn" : 31
                }
              },
              "message" : {
                "text" : "selection of Email"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 354,
                  "startColumn" : 2,
                  "endColumn" : 9
                }
              },
              "message" : {
                "text" : "implicit dereference [Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 350,
                  "startColumn" : 2,
                  "endColumn" : 9
                }
              },
              "message" : {
                "text" : "definition of profile [pointer, Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 356,
                  "startColumn" : 9,
                  "endColumn" : 16
                }
              },
              "message" : {
                "text" : "profile [pointer, Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 440,
                  "startColumn" : 13,
                  "endColumn" : 26
                }
              },
              "message" : {
                "text" : "call to GetProfile [pointer, Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 453,
                  "startColumn" : 25,
                  "endColumn" : 32
                }
              },
              "message" : {
                "text" : "profile [pointer, Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 196,
                  "startColumn" : 25,
                  "endColumn" : 32
                }
              },
              "message" : {
                "text" : "definition of profile [pointer, Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 198,
                  "startColumn" : 139,
                  "endColumn" : 146
                }
              },
              "message" : {
                "text" : "profile [pointer, Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 198,
                  "startColumn" : 139,
                  "endColumn" : 146
                }
              },
              "message" : {
                "text" : "implicit dereference [Login]"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 198,
                  "startColumn" : 139,
                  "endColumn" : 152
                }
              },
              "message" : {
                "text" : "selection of Login"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 198,
                  "startColumn" : 11,
                  "endColumn" : 153
                }
              },
              "message" : {
                "text" : "call to Sprintf"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 200,
                  "startColumn" : 26,
                  "endColumn" : 31
                }
              },
              "message" : {
                "text" : "query"
              }
            }
          } ]
        } ]
      }, {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 377,
                  "startColumn" : 25,
                  "endColumn" : 31
                }
              },
              "message" : {
                "text" : "selection of Body"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 377,
                  "startColumn" : 9,
                  "endColumn" : 32
                }
              },
              "message" : {
                "text" : "call to NewDecoder"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 377,
                  "startColumn" : 40,
                  "endColumn" : 48
                }
              },
              "message" : {
                "text" : "&..."
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 383,
                  "startColumn" : 8,
                  "endColumn" : 15
                }
              },
              "message" : {
                "text" : "gallery"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 196,
                  "startColumn" : 7,
                  "endColumn" : 8
                }
              },
              "message" : {
                "text" : "definition of g"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 198,
                  "startColumn" : 109,
                  "endColumn" : 116
                }
              },
              "message" : {
                "text" : "selection of Title"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 198,
                  "startColumn" : 11,
                  "endColumn" : 153
                }
              },
              "message" : {
                "text" : "call to Sprintf"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 200,
                  "startColumn" : 26,
                  "endColumn" : 31
                }
              },
              "message" : {
                "text" : "query"
              }
            }
          } ]
        } ]
      } ],
      "relatedLocations" : [ {
        "id" : 1,
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "gallery/main.go",
            "uriBaseId" : "%SRCROOT%",
            "index" : 0
          },
          "region" : {
            "startLine" : 352,
            "startColumn" : 17,
            "endColumn" : 25
          }
        },
        "message" : {
          "text" : "user-provided value"
        }
      }, {
        "id" : 2,
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "gallery/main.go",
            "uriBaseId" : "%SRCROOT%",
            "index" : 0
          },
          "region" : {
            "startLine" : 353,
            "startColumn" : 18,
            "endColumn" : 26
          }
        },
        "message" : {
          "text" : "user-provided value"
        }
      }, {
        "id" : 3,
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "gallery/main.go",
            "uriBaseId" : "%SRCROOT%",
            "index" : 0
          },
          "region" : {
            "startLine" : 377,
            "startColumn" : 25,
            "endColumn" : 31
          }
        },
        "message" : {
          "text" : "user-provided value"
        }
      } ]
    }, {
      "ruleId" : "go/sql-injection",
      "rule" : {
        "id" : "go/sql-injection",
        "index" : 8,
        "toolComponent" : {
          "index" : 0
        }
      },
      "message" : {
        "text" : "This query depends on a [user-provided value](1)."
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "gallery/main.go",
            "uriBaseId" : "%SRCROOT%",
            "index" : 0
          },
          "region" : {
            "startLine" : 309,
            "startColumn" : 26,
            "endColumn" : 31
          }
        }
      } ],
      "partialFingerprints" : {
        "primaryLocationLineHash" : "cffaf601b82e3e2e:1",
        "primaryLocationStartColumnFingerprint" : "24"
      },
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 541,
                  "startColumn" : 24,
                  "endColumn" : 30
                }
              },
              "message" : {
                "text" : "selection of Body"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 541,
                  "startColumn" : 8,
                  "endColumn" : 31
                }
              },
              "message" : {
                "text" : "call to NewDecoder"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 541,
                  "startColumn" : 39,
                  "endColumn" : 49
                }
              },
              "message" : {
                "text" : "&..."
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 549,
                  "startColumn" : 8,
                  "endColumn" : 17
                }
              },
              "message" : {
                "text" : "art_piece"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 305,
                  "startColumn" : 7,
                  "endColumn" : 8
                }
              },
              "message" : {
                "text" : "definition of p"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 308,
                  "startColumn" : 142,
                  "endColumn" : 149
                }
              },
              "message" : {
                "text" : "selection of Title"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 308,
                  "startColumn" : 11,
                  "endColumn" : 199
                }
              },
              "message" : {
                "text" : "call to Sprintf"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 309,
                  "startColumn" : 26,
                  "endColumn" : 31
                }
              },
              "message" : {
                "text" : "query"
              }
            }
          } ]
        } ]
      }, {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 541,
                  "startColumn" : 24,
                  "endColumn" : 30
                }
              },
              "message" : {
                "text" : "selection of Body"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 541,
                  "startColumn" : 8,
                  "endColumn" : 31
                }
              },
              "message" : {
                "text" : "call to NewDecoder"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 541,
                  "startColumn" : 39,
                  "endColumn" : 49
                }
              },
              "message" : {
                "text" : "&..."
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 549,
                  "startColumn" : 8,
                  "endColumn" : 17
                }
              },
              "message" : {
                "text" : "art_piece"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 305,
                  "startColumn" : 7,
                  "endColumn" : 8
                }
              },
              "message" : {
                "text" : "definition of p"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 308,
                  "startColumn" : 151,
                  "endColumn" : 164
                }
              },
              "message" : {
                "text" : "selection of Description"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 308,
                  "startColumn" : 11,
                  "endColumn" : 199
                }
              },
              "message" : {
                "text" : "call to Sprintf"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 309,
                  "startColumn" : 26,
                  "endColumn" : 31
                }
              },
              "message" : {
                "text" : "query"
              }
            }
          } ]
        } ]
      }, {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 541,
                  "startColumn" : 24,
                  "endColumn" : 30
                }
              },
              "message" : {
                "text" : "selection of Body"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 541,
                  "startColumn" : 8,
                  "endColumn" : 31
                }
              },
              "message" : {
                "text" : "call to NewDecoder"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 541,
                  "startColumn" : 39,
                  "endColumn" : 49
                }
              },
              "message" : {
                "text" : "&..."
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 549,
                  "startColumn" : 8,
                  "endColumn" : 17
                }
              },
              "message" : {
                "text" : "art_piece"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 305,
                  "startColumn" : 7,
                  "endColumn" : 8
                }
              },
              "message" : {
                "text" : "definition of p"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 308,
                  "startColumn" : 175,
                  "endColumn" : 180
                }
              },
              "message" : {
                "text" : "selection of Uri"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 308,
                  "startColumn" : 11,
                  "endColumn" : 199
                }
              },
              "message" : {
                "text" : "call to Sprintf"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 309,
                  "startColumn" : 26,
                  "endColumn" : 31
                }
              },
              "message" : {
                "text" : "query"
              }
            }
          } ]
        } ]
      } ],
      "relatedLocations" : [ {
        "id" : 1,
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "gallery/main.go",
            "uriBaseId" : "%SRCROOT%",
            "index" : 0
          },
          "region" : {
            "startLine" : 541,
            "startColumn" : 24,
            "endColumn" : 30
          }
        },
        "message" : {
          "text" : "user-provided value"
        }
      } ]
    }, {
      "ruleId" : "go/clear-text-logging",
      "rule" : {
        "id" : "go/clear-text-logging",
        "index" : 10,
        "toolComponent" : {
          "index" : 0
        }
      },
      "message" : {
        "text" : "[Sensitive data returned by HTTP request headers](1) flows to a logging call."
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "gallery/main.go",
            "uriBaseId" : "%SRCROOT%",
            "index" : 0
          },
          "region" : {
            "startLine" : 660,
            "startColumn" : 50,
            "endColumn" : 61
          }
        }
      } ],
      "partialFingerprints" : {
        "primaryLocationLineHash" : "3154cb2d7c20d91d:1",
        "primaryLocationStartColumnFingerprint" : "46"
      },
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 656,
                  "startColumn" : 12,
                  "endColumn" : 20
                }
              },
              "message" : {
                "text" : "selection of Header"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 656,
                  "startColumn" : 12,
                  "endColumn" : 41
                }
              },
              "message" : {
                "text" : "call to Get"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 656,
                  "startColumn" : 3,
                  "endColumn" : 8
                }
              },
              "message" : {
                "text" : "definition of authz"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 659,
                  "startColumn" : 56,
                  "endColumn" : 61
                }
              },
              "message" : {
                "text" : "authz"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 659,
                  "startColumn" : 37,
                  "endColumn" : 72
                }
              },
              "message" : {
                "text" : "call to TrimPrefix"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 659,
                  "startColumn" : 19,
                  "endColumn" : 73
                }
              },
              "message" : {
                "text" : "call to TrimSpace"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 659,
                  "startColumn" : 4,
                  "endColumn" : 15
                }
              },
              "message" : {
                "text" : "definition of tokenString"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 660,
                  "startColumn" : 50,
                  "endColumn" : 61
                }
              },
              "message" : {
                "text" : "tokenString"
              }
            }
          } ]
        } ]
      } ],
      "relatedLocations" : [ {
        "id" : 1,
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "gallery/main.go",
            "uriBaseId" : "%SRCROOT%",
            "index" : 0
          },
          "region" : {
            "startLine" : 656,
            "startColumn" : 12,
            "endColumn" : 20
          }
        },
        "message" : {
          "text" : "Sensitive data returned by HTTP request headers"
        }
      } ]
    }, {
      "ruleId" : "go/clear-text-logging",
      "rule" : {
        "id" : "go/clear-text-logging",
        "index" : 10,
        "toolComponent" : {
          "index" : 0
        }
      },
      "message" : {
        "text" : "[Sensitive data returned by HTTP request headers](1) flows to a logging call."
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "gallery/main.go",
            "uriBaseId" : "%SRCROOT%",
            "index" : 0
          },
          "region" : {
            "startLine" : 678,
            "startColumn" : 50,
            "endColumn" : 55
          }
        }
      } ],
      "partialFingerprints" : {
        "primaryLocationLineHash" : "44645d539be4d0e4:1",
        "primaryLocationStartColumnFingerprint" : "45"
      },
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 656,
                  "startColumn" : 12,
                  "endColumn" : 20
                }
              },
              "message" : {
                "text" : "selection of Header"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 656,
                  "startColumn" : 12,
                  "endColumn" : 41
                }
              },
              "message" : {
                "text" : "call to Get"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 656,
                  "startColumn" : 3,
                  "endColumn" : 8
                }
              },
              "message" : {
                "text" : "definition of authz"
              }
            }
          }, {
            "location" : {
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "gallery/main.go",
                  "uriBaseId" : "%SRCROOT%",
                  "index" : 0
                },
                "region" : {
                  "startLine" : 678,
                  "startColumn" : 50,
                  "endColumn" : 55
                }
              },
              "message" : {
                "text" : "authz"
              }
            }
          } ]
        } ]
      } ],
      "relatedLocations" : [ {
        "id" : 1,
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "gallery/main.go",
            "uriBaseId" : "%SRCROOT%",
            "index" : 0
          },
          "region" : {
            "startLine" : 656,
            "startColumn" : 12,
            "endColumn" : 20
          }
        },
        "message" : {
          "text" : "Sensitive data returned by HTTP request headers"
        }
      } ]
    } ],
    "automationDetails" : {
      "id" : "/language:go/"
    },
    "columnKind" : "utf16CodeUnits",
    "properties" : {
      "codeqlConfigSummary" : {
        "disableDefaultQueries" : false,
        "queries" : [ {
          "type" : "localQuery",
          "uses" : "./queries/vue-xss.ql"
        } ]
      },
      "metricResults" : [ {
        "rule" : {
          "id" : "go/summary/lines-of-code",
          "index" : 26,
          "toolComponent" : {
            "index" : 0
          }
        },
        "ruleId" : "go/summary/lines-of-code",
        "value" : 2019,
        "baseline" : 2019
      } ],
      "semmle.formatSpecifier" : "sarif-latest"
    }
  } ]
}